================
File: src/lib/server/domain/media/games/games.types.ts
================
import {TopMetricStats} from "@/lib/server/types/base.types";
import {games, gamesList} from "@/lib/server/database/schema";
import {gamesAchievements} from "@/lib/server/domain/media/games/achievements.seed";
export type Game = typeof games.$inferSelect;
export type GamesList = typeof gamesList.$inferSelect;
export type UpsertGameWithDetails = {
    mediaData: typeof games.$inferInsert,
    genresData: { name: string }[],
    platformsData: { name: string }[],
    companiesData: { name: string, developer: boolean, publisher: boolean }[],
};
export type GamesTopMetricStats = {
    enginesStats: TopMetricStats;
    platformsStats: TopMetricStats;
    developersStats: TopMetricStats;
    publishersStats: TopMetricStats;
    perspectivesStats: TopMetricStats;
};
export type GamesAchCodeName = typeof gamesAchievements[number]["codeName"];

================
File: src/lib/server/domain/media/movies/movies.types.ts
================
import {TopMetricStats} from "@/lib/server/types/base.types";
import {movies, moviesList} from "@/lib/server/database/schema";
import {moviesAchievements} from "@/lib/server/domain/media/movies/achievements.seed";
export type Movie = typeof movies.$inferSelect;
export type MoviesList = typeof moviesList.$inferSelect;
export type UpsertMovieWithDetails = {
    mediaData: typeof movies.$inferInsert,
    actorsData?: { name: string }[],
    genresData?: { name: string }[],
};
export type MoviesTopMetricStats = {
    langsStats: TopMetricStats;
    actorsStats: TopMetricStats;
    directorsStats: TopMetricStats;
};
export type MoviesAchCodeName = typeof moviesAchievements[number]["codeName"];

================
File: src/lib/server/types/provider.types.ts
================
import {ApiProviderType, MediaType} from "@/lib/server/utils/enums";
export interface IProviderService {
    bulkProcessAndRefreshMedia(): Promise<PromiseSettledResult<boolean>[]>;
    fetchAndRefreshMediaDetails(apiId: number, isBulk?: boolean): Promise<boolean>;
    fetchAndStoreMediaDetails(apiId: number, isBulk?: boolean): Promise<number | undefined>;
}
export interface ITrendsProviderService extends IProviderService {
    fetchAndFormatTrends(): Promise<TrendsMedia[]>;
}
export interface ProviderSearchResults {
    id: number | string
    date: string | undefined | null
    name: string | undefined | null
    image: string | undefined | null
    itemType: MediaType | ApiProviderType
}
export type TrendsMedia = {
    apiId: number,
    overview: string,
    posterPath: string,
    displayName: string,
    releaseDate: string,
    mediaType: MediaType,
}

================
File: src/lib/server/domain/media/tv/anime/anime-provider.service.ts
================
import {IProviderService} from "@/lib/server/types/provider.types";
import {TvRepository} from "@/lib/server/domain/media/tv/tv.repository";
import {TmdbClient} from "@/lib/server/media-providers/clients/tmdb.client";
import {JikanClient} from "@/lib/server/media-providers/clients/jikan.client";
import {TmdbTransformer} from "@/lib/server/media-providers/transformers/tmdb.transformer";
export class AnimeProviderService implements IProviderService {
    constructor(
        private client: TmdbClient,
        private jikanClient: JikanClient,
        private transformer: TmdbTransformer,
        private repository: TvRepository,
    ) {
    }
    async fetchAndStoreMediaDetails(apiId: number, isBulk: boolean = false) {
        const rawData = await this.client.getTvDetails(apiId);
        const { mediaData, actorsData, seasonsData, networkData, genresData } = await this.transformer.transformAnimeDetailsResults(rawData);
        let extendedGenresData = genresData;
        if (!isBulk) {
            const jikanData = await this.jikanClient.getAnimeGenresAndDemographics(mediaData.name);
            extendedGenresData = this.transformer.addAnimeSpecificGenres(jikanData, genresData);
        }
        return this.repository.storeMediaWithDetails({ mediaData, actorsData, seasonsData, networkData, genresData: extendedGenresData });
    }
    async fetchAndRefreshMediaDetails(apiId: number, isBulk: boolean = false) {
        try {
            const rawData = await this.client.getTvDetails(apiId);
            const { mediaData, actorsData, seasonsData, networkData, genresData } = await this.transformer.transformAnimeDetailsResults(rawData);
            let extendedGenresData = genresData;
            if (isBulk) {
                extendedGenresData = null;
            }
            else {
                const jikanData = await this.jikanClient.getAnimeGenresAndDemographics(mediaData.name);
                extendedGenresData = this.transformer.addAnimeSpecificGenres(jikanData, genresData);
            }
            return this.repository.updateMediaWithDetails({ mediaData, actorsData, seasonsData, networkData, genresData: extendedGenresData });
        }
        catch (error: any) {
            error.message = `Error refreshing Anime with apiId ${apiId}: ${error.message}`;
            throw error;
        }
    }
    async bulkProcessAndRefreshMedia() {
        const changedApiIds = await this.client.getTvChangedIds();
        const mediaIds = await this.repository.getMediaIdsToBeRefreshed(changedApiIds);
        const promises = [];
        for (const apiId of mediaIds) {
            promises.push(this.fetchAndRefreshMediaDetails(apiId, true));
        }
        return Promise.allSettled(promises);
    }
}

================
File: src/lib/server/domain/media/tv/series/series-provider.service.ts
================
import {TvRepository} from "@/lib/server/domain/media/tv/tv.repository";
import {ITrendsProviderService} from "@/lib/server/types/provider.types";
import {TmdbClient} from "@/lib/server/media-providers/clients/tmdb.client";
import {TmdbTransformer} from "@/lib/server/media-providers/transformers/tmdb.transformer";
export class SeriesProviderService implements ITrendsProviderService {
    constructor(
        private client: TmdbClient,
        private transformer: TmdbTransformer,
        private repository: TvRepository,
    ) {
    }
    async fetchAndStoreMediaDetails(apiId: number) {
        const rawData = await this.client.getTvDetails(apiId);
        const { mediaData, genresData, seasonsData, actorsData, networkData } = await this.transformer.transformSeriesDetailsResults(rawData);
        return this.repository.storeMediaWithDetails({ mediaData, seasonsData, actorsData, networkData, genresData });
    }
    async fetchAndRefreshMediaDetails(apiId: number) {
        try {
            const rawData = await this.client.getTvDetails(apiId);
            const { mediaData, seasonsData, actorsData, networkData, genresData } = await this.transformer.transformSeriesDetailsResults(rawData);
            return this.repository.updateMediaWithDetails({ mediaData, seasonsData, actorsData, networkData, genresData });
        }
        catch (error: any) {
            error.message = `Error refreshing Series with apiId ${apiId}: ${error.message}`;
            throw error;
        }
    }
    async bulkProcessAndRefreshMedia() {
        const changedApiIds = await this.client.getTvChangedIds();
        const mediaIds = await this.repository.getMediaIdsToBeRefreshed(changedApiIds);
        const promises = [];
        for (const apiId of mediaIds) {
            promises.push(this.fetchAndRefreshMediaDetails(apiId));
        }
        return Promise.allSettled(promises);
    }
    async fetchAndFormatTrends() {
        const rawData = await this.client.getTvTrending();
        const tvTrends = this.transformer.transformSeriesTrends(rawData);
        return tvTrends;
    }
}

================
File: src/lib/server/domain/media/tv/tv.types.ts
================
import {EpsPerSeasonType, TopMetricStats} from "@/lib/server/types/base.types";
import {anime, animeList, series, seriesList} from "@/lib/server/database/schema";
import {animeAchievements} from "@/lib/server/domain/media/tv/anime/achievements.seed";
import {seriesAchievements} from "@/lib/server/domain/media/tv/series/achievements.seed";
export type Series = typeof series.$inferSelect & { epsPerSeason?: EpsPerSeasonType };
export type Anime = typeof anime.$inferSelect & { epsPerSeason?: EpsPerSeasonType };
export type SeriesList = typeof seriesList.$inferSelect & { epsPerSeason?: EpsPerSeasonType };
export type AnimeList = typeof animeList.$inferSelect & { epsPerSeason?: EpsPerSeasonType };
export type TvType = Series | Anime;
export type TvList = SeriesList | AnimeList;
export type AnimeAchCodeName = typeof animeAchievements[number]["codeName"];
export type SeriesAchCodeName = typeof seriesAchievements[number]["codeName"];
export type TvAchCodeName = AnimeAchCodeName | SeriesAchCodeName;
export type UpsertTvWithDetails = {
    mediaData: typeof series.$inferInsert | typeof anime.$inferInsert,
    actorsData: { name: string }[],
    networkData: { name: string }[],
    genresData: { name: string }[] | null,
    seasonsData: { season: number, episodes: number }[],
};
export type TvTopMetricStats = {
    actorsStats: TopMetricStats;
    networksStats: TopMetricStats;
    countriesStats: TopMetricStats;
};

================
File: src/lib/server/domain/media/games/games-provider.service.ts
================
import {IProviderService} from "@/lib/server/types/provider.types";
import {HltbClient} from "@/lib/server/media-providers/clients/hltb.client";
import {IgdbClient} from "@/lib/server/media-providers/clients/igdb.client";
import {GamesRepository} from "@/lib/server/domain/media/games/games.repository";
import {IgdbTransformer} from "@/lib/server/media-providers/transformers/igdb.transformer";
export class GamesProviderService implements IProviderService {
    constructor(
        private readonly client: IgdbClient,
        private readonly hltbClient: HltbClient,
        private readonly transformer: IgdbTransformer,
        private readonly repository: GamesRepository
    ) {
    }
    async fetchAndStoreMediaDetails(apiId: number, isBulk: boolean = false) {
        const details = await this._getMediaDetails(apiId, isBulk);
        return this.repository.storeMediaWithDetails(details);
    }
    async fetchAndRefreshMediaDetails(apiId: number, isBulk: boolean = false) {
        try {
            const details = await this._getMediaDetails(apiId, isBulk);
            return this.repository.updateMediaWithDetails(details);
        }
        catch (err: any) {
            throw new Error(`Error refreshing game with apiId ${apiId}: ${err.message}`);
        }
    }
    async bulkProcessAndRefreshMedia() {
        const mediaIdsToBeRefreshed = await this.repository.getMediaIdsToBeRefreshed();
        const promises = mediaIdsToBeRefreshed.map((apiId) => this.fetchAndRefreshMediaDetails(apiId, true));
        return Promise.allSettled(promises);
    }
    private async _getMediaDetails(apiId: number, isBulk: boolean) {
        const rawData = await this.client.getGameDetails(apiId);
        const { mediaData, genresData, companiesData, platformsData } = await this.transformer.transformGamesDetailsResults(rawData);
        let extendedMediaData = mediaData;
        if (!isBulk) {
            const hltbData = await this.hltbClient.search(mediaData.name);
            console.log({ hltbData });
            extendedMediaData = this.transformer.addHLTBDataToMainDetails(hltbData, mediaData);
        }
        return { mediaData: extendedMediaData, companiesData, platformsData, genresData };
    }
}

================
File: src/lib/server/domain/media/games/games.config.ts
================
import {asc, desc, getTableColumns} from "drizzle-orm";
import {Status} from "@/lib/server/utils/enums";
import * as schema from "@/lib/server/database/schema";
import {MediaSchemaConfig} from "@/lib/server/types/media-lists.types";
import {createListFilterDef} from "@/lib/server/domain/media/base/base.repository";
export type GamesSchemaConfig = MediaSchemaConfig<
    typeof schema.games,
    typeof schema.gamesList,
    typeof schema.gamesGenre,
    typeof schema.gamesLabels
>;
export const gamesConfig: GamesSchemaConfig = {
    mediaTable: schema.games,
    listTable: schema.gamesList,
    genreTable: schema.gamesGenre,
    labelTable: schema.gamesLabels,
    mediaList: {
        baseSelection: {
            mediaName: schema.games.name,
            imageCover: schema.games.imageCover,
            ...getTableColumns(schema.gamesList),
        },
        filterDefinitions: {
            platforms: createListFilterDef({
                argName: "platforms",
                mediaTable: schema.games,
                entityTable: schema.gamesPlatforms,
                filterColumn: schema.gamesPlatforms.name,
            }),
            companies: createListFilterDef({
                argName: "companies",
                mediaTable: schema.games,
                entityTable: schema.gamesCompanies,
                filterColumn: schema.gamesCompanies.name,
            }),
        },
        defaultStatus: Status.PLAYING,
        defaultSortName: "Playtime +",
        availableSorts: {
            "Title A-Z": asc(schema.games.name),
            "Title Z-A": desc(schema.games.name),
            "Release Date +": [desc(schema.games.releaseDate), asc(schema.games.name)],
            "Release Date -": [asc(schema.games.releaseDate), asc(schema.games.name)],
            "IGDB Rating +": [desc(schema.games.voteAverage), asc(schema.games.name)],
            "IGDB Rating -": [asc(schema.games.voteAverage), asc(schema.games.name)],
            "Rating +": [desc(schema.gamesList.rating), asc(schema.games.name)],
            "Rating -": [asc(schema.gamesList.rating), asc(schema.games.name)],
            "Playtime +": [desc(schema.gamesList.playtime), asc(schema.games.name)],
            "Playtime -": [asc(schema.gamesList.playtime), asc(schema.games.name)],
        },
    },
    apiProvider: {
        maxGenres: 5,
    },
    editableFields: [
        "name", "gameEngine", "gameModes", "playerPerspective", "releaseDate", "synopsis",
        "hltbMainTime", "hltbMainAndExtraTime", "hltbTotalCompleteTime"
    ],
    tablesForDeletion: [schema.gamesCompanies, schema.gamesPlatforms, schema.gamesGenre, schema.gamesLabels],
};

================
File: src/lib/server/domain/media/tv/anime/anime.config.ts
================
import {Status} from "@/lib/server/utils/enums";
import * as schema from "@/lib/server/database/schema";
import {asc, desc, getTableColumns, sql} from "drizzle-orm";
import {TVSchemaConfig} from "@/lib/server/types/media-lists.types";
import {createListFilterDef} from "@/lib/server/domain/media/base/base.repository";
export type AnimeSchemaConfig = TVSchemaConfig<
    typeof schema.anime,
    typeof schema.animeList,
    typeof schema.animeGenre,
    typeof schema.animeLabels,
    typeof schema.animeActors,
    typeof schema.animeNetwork,
    typeof schema.animeEpisodesPerSeason
>;
export const animeConfig: AnimeSchemaConfig = {
    mediaTable: schema.anime,
    listTable: schema.animeList,
    genreTable: schema.animeGenre,
    labelTable: schema.animeLabels,
    actorTable: schema.animeActors,
    networkTable: schema.animeNetwork,
    epsPerSeasonTable: schema.animeEpisodesPerSeason,
    mediaList: {
        baseSelection: {
            mediaName: schema.anime.name,
            imageCover: schema.anime.imageCover,
            epsPerSeason: sql<{ season: number; episodes: number }[]>`(
                SELECT
                    json_group_array(json_object(
                        'season', ${schema.animeEpisodesPerSeason.season},
                        'episodes', ${schema.animeEpisodesPerSeason.episodes}
                    ))
                FROM ${schema.animeEpisodesPerSeason}
                WHERE ${schema.animeEpisodesPerSeason.mediaId} = ${schema.anime.id}
            )`.mapWith(JSON.parse),
            ...getTableColumns(schema.animeList),
        },
        filterDefinitions: {
            actors: createListFilterDef({
                argName: "actors",
                mediaTable: schema.anime,
                entityTable: schema.animeActors,
                filterColumn: schema.animeActors.name,
            }),
            networks: createListFilterDef({
                argName: "networks",
                mediaTable: schema.anime,
                entityTable: schema.animeNetwork,
                filterColumn: schema.animeNetwork.name,
            }),
        },
        defaultStatus: Status.WATCHING,
        defaultSortName: "Title A-Z",
        availableSorts: {
            "Title A-Z": asc(schema.anime.name),
            "Title Z-A": desc(schema.anime.name),
            "Release Date +": [desc(schema.anime.releaseDate), asc(schema.anime.name)],
            "Release Date -": [asc(schema.anime.releaseDate), asc(schema.anime.name)],
            "TMDB Rating +": [desc(schema.anime.voteAverage), asc(schema.anime.name)],
            "TMDB Rating -": [asc(schema.anime.voteAverage), asc(schema.anime.name)],
            "Rating +": [desc(schema.animeList.rating), asc(schema.anime.name)],
            "Rating -": [asc(schema.animeList.rating), asc(schema.anime.name)],
            "Re-watched": [desc(schema.animeList.redo), asc(schema.anime.name)],
        },
    },
    apiProvider: {
        maxGenres: 5,
    },
    editableFields: [
        "name", "originalName", "releaseDate", "lastAirDate", "homepage",
        "createdBy", "duration", "originCountry", "prodStatus", "synopsis"
    ],
    tablesForDeletion: [schema.animeActors, schema.animeGenre, schema.animeLabels],
};

================
File: src/lib/server/domain/media/tv/series/series.config.ts
================
import {Status} from "@/lib/server/utils/enums";
import * as schema from "@/lib/server/database/schema";
import {asc, desc, getTableColumns, sql} from "drizzle-orm";
import {TVSchemaConfig} from "@/lib/server/types/media-lists.types";
import {createListFilterDef} from "@/lib/server/domain/media/base/base.repository";
export type SeriesSchemaConfig = TVSchemaConfig<
    typeof schema.series,
    typeof schema.seriesList,
    typeof schema.seriesGenre,
    typeof schema.seriesLabels,
    typeof schema.seriesActors,
    typeof schema.seriesNetwork,
    typeof schema.seriesEpisodesPerSeason
>;
export const seriesConfig: SeriesSchemaConfig = {
    mediaTable: schema.series,
    listTable: schema.seriesList,
    genreTable: schema.seriesGenre,
    labelTable: schema.seriesLabels,
    actorTable: schema.seriesActors,
    networkTable: schema.seriesNetwork,
    epsPerSeasonTable: schema.seriesEpisodesPerSeason,
    mediaList: {
        baseSelection: {
            mediaName: schema.series.name,
            imageCover: schema.series.imageCover,
            epsPerSeason: sql<{ season: number; episodes: number }[]>`(
                SELECT
                    json_group_array(json_object(
                        'season', ${schema.seriesEpisodesPerSeason.season},
                        'episodes', ${schema.seriesEpisodesPerSeason.episodes}
                    ))
                FROM ${schema.seriesEpisodesPerSeason}
                WHERE ${schema.seriesEpisodesPerSeason.mediaId} = ${schema.series.id}
            )`.mapWith(JSON.parse),
            ...getTableColumns(schema.seriesList),
        },
        filterDefinitions: {
            actors: createListFilterDef({
                argName: "actors",
                mediaTable: schema.series,
                entityTable: schema.seriesActors,
                filterColumn: schema.seriesActors.name,
            }),
            networks: createListFilterDef({
                argName: "networks",
                mediaTable: schema.series,
                entityTable: schema.seriesNetwork,
                filterColumn: schema.seriesNetwork.name,
            }),
        },
        defaultStatus: Status.WATCHING,
        defaultSortName: "Title A-Z",
        availableSorts: {
            "Title A-Z": asc(schema.series.name),
            "Title Z-A": desc(schema.series.name),
            "Release Date +": [desc(schema.series.releaseDate), asc(schema.series.name)],
            "Release Date -": [asc(schema.series.releaseDate), asc(schema.series.name)],
            "TMDB Rating +": [desc(schema.series.voteAverage), asc(schema.series.name)],
            "TMDB Rating -": [asc(schema.series.voteAverage), asc(schema.series.name)],
            "Rating +": [desc(schema.seriesList.rating), asc(schema.series.name)],
            "Rating -": [asc(schema.seriesList.rating), asc(schema.series.name)],
            "Re-watched": [desc(schema.seriesList.redo), asc(schema.series.name)],
        },
    },
    apiProvider: {
        maxGenres: 5,
    },
    editableFields: [
        "name", "originalName", "releaseDate", "lastAirDate", "homepage",
        "createdBy", "duration", "originCountry", "prodStatus", "synopsis"
    ],
    tablesForDeletion: [schema.seriesActors, schema.seriesGenre, schema.seriesLabels],
};

================
File: src/lib/server/domain/media/base/base.service.ts
================
import {JobType} from "@/lib/server/utils/enums";
import {Achievement} from "@/lib/server/types/achievements.types";
import {IUniversalService} from "@/lib/server/types/services.types";
import {ICommonRepository} from "@/lib/server/types/repositories.types";
import {EditUserLabels, MediaListArgs, SearchType} from "@/lib/server/types/base.types";
export abstract class BaseService<
    TMedia, TList, TStats, TCodeName extends string, R extends ICommonRepository<TMedia, TList>
> implements IUniversalService<TMedia, TList> {
    protected repository: R;
    protected abstract readonly achievementHandlers: Record<TCodeName, (achievement: Achievement, userId?: number) => any>;
    constructor(repository: R) {
        this.repository = repository;
    }
    async findById(mediaId: number) {
        return this.repository.findById(mediaId);
    }
    getAchievementCte(achievement: Achievement, userId?: number) {
        const handler = this.achievementHandlers[achievement.codeName as TCodeName];
        if (!handler) {
            throw new Error(`Invalid Achievement codeName: ${achievement.codeName}`);
        }
        return handler(achievement, userId);
    }
    async downloadMediaListAsCSV(userId: number) {
        return this.repository.downloadMediaListAsCSV(userId);
    }
    async searchByName(query: string) {
        return this.repository.searchByName(query);
    }
    async removeMediaByIds(mediaIds: number[]) {
        return this.repository.removeMediaByIds(mediaIds);
    }
    async getNonListMediaIds() {
        return this.repository.getNonListMediaIds();
    }
    async getCoverFilenames() {
        const coverFilenames = await this.repository.getCoverFilenames();
        return coverFilenames.map(({ imageCover }) => imageCover.split("/").pop() as string);
    }
    async getMediaToNotify() {
        return this.repository.getMediaToNotify();
    }
    async computeAllUsersStats() {
        return this.repository.computeAllUsersStats();
    }
    async computeTotalMediaLabel(userId?: number) {
        return this.repository.computeTotalMediaLabel(userId);
    }
    async getUserMediaLabels(userId: number) {
        return await this.repository.getUserMediaLabels(userId);
    }
    async editUserLabel({ userId, label, mediaId, action }: EditUserLabels) {
        return this.repository.editUserLabel({ userId, label, mediaId, action });
    }
    async getMediaList(currentUserId: number | undefined, userId: number, args: MediaListArgs) {
        return this.repository.getMediaList(currentUserId, userId, args);
    }
    async getListFilters(userId: number) {
        return this.repository.getListFilters(userId);
    }
    async getMediaJobDetails(userId: number, job: JobType, name: string, search: SearchType) {
        const page = search.page ?? 1;
        const perPage = search.perPage ?? 25;
        const offset = (page - 1) * perPage;
        return this.repository.getMediaJobDetails(userId, job, name, offset, perPage);
    }
    async getSearchListFilters(userId: number, query: string, job: JobType) {
        return this.repository.getSearchListFilters(userId, query, job);
    }
}

================
File: src/lib/server/domain/media/movies/movies-provider.service.ts
================
import {ITrendsProviderService} from "@/lib/server/types/provider.types";
import {TmdbClient} from "@/lib/server/media-providers/clients/tmdb.client";
import {MoviesRepository} from "@/lib/server/domain/media/movies/movies.repository";
import {TmdbTransformer} from "@/lib/server/media-providers/transformers/tmdb.transformer";
export class MoviesProviderService implements ITrendsProviderService {
    constructor(
        private client: TmdbClient,
        private transformer: TmdbTransformer,
        private repository: MoviesRepository,
    ) {
    }
    async fetchAndStoreMediaDetails(apiId: number) {
        const rawData = await this.client.getMovieDetails(apiId);
        const { mediaData, actorsData, genresData } = await this.transformer.transformMoviesDetailsResults(rawData);
        return this.repository.storeMediaWithDetails({ mediaData, actorsData, genresData });
    }
    async fetchAndRefreshMediaDetails(apiId: number) {
        try {
            const rawData = await this.client.getMovieDetails(apiId);
            const { mediaData, actorsData, genresData } = await this.transformer.transformMoviesDetailsResults(rawData);
            return this.repository.updateMediaWithDetails({ mediaData, actorsData, genresData });
        }
        catch (err: any) {
            err.message = `Error refreshing movie with apiId ${apiId}: ${err.message}`;
            throw err;
        }
    }
    async bulkProcessAndRefreshMedia() {
        const mediaIdsToBeRefreshed = await this.repository.getMediaIdsToBeRefreshed();
        const promises = [];
        for (const apiId of mediaIdsToBeRefreshed) {
            promises.push(this.fetchAndRefreshMediaDetails(apiId));
        }
        return Promise.allSettled(promises);
    }
    async fetchAndFormatTrends() {
        const rawData = await this.client.getMoviesTrending();
        const moviesTrends = this.transformer.transformMoviesTrends(rawData);
        return moviesTrends;
    }
}

================
File: src/lib/server/domain/media/movies/movies.config.ts
================
import {Status} from "@/lib/server/utils/enums";
import * as schema from "@/lib/server/database/schema";
import {asc, desc, getTableColumns} from "drizzle-orm";
import {MediaSchemaConfig} from "@/lib/server/types/media-lists.types";
import {createListFilterDef} from "@/lib/server/domain/media/base/base.repository";
export type MovieSchemaConfig = MediaSchemaConfig<
    typeof schema.movies,
    typeof schema.moviesList,
    typeof schema.moviesGenre,
    typeof schema.moviesLabels
>;
export const moviesConfig: MovieSchemaConfig = {
    mediaTable: schema.movies,
    listTable: schema.moviesList,
    genreTable: schema.moviesGenre,
    labelTable: schema.moviesLabels,
    mediaList: {
        baseSelection: {
            mediaName: schema.movies.name,
            imageCover: schema.movies.imageCover,
            directorName: schema.movies.directorName,
            originalLanguage: schema.movies.originalLanguage,
            ...getTableColumns(schema.moviesList),
        },
        filterDefinitions: {
            actors: createListFilterDef({
                argName: "actors",
                mediaTable: schema.movies,
                entityTable: schema.moviesActors,
                filterColumn: schema.moviesActors.name,
            }),
        },
        defaultStatus: Status.COMPLETED,
        defaultSortName: "Title A-Z",
        availableSorts: {
            "Title A-Z": asc(schema.movies.name),
            "Title Z-A": desc(schema.movies.name),
            "Rating +": [desc(schema.moviesList.rating), asc(schema.movies.name)],
            "Rating -": [asc(schema.moviesList.rating), asc(schema.movies.name)],
            "TMDB Rating +": [desc(schema.movies.voteAverage), asc(schema.movies.name)],
            "TMDB Rating -": [asc(schema.movies.voteAverage), asc(schema.movies.name)],
            "Release Date +": [desc(schema.movies.releaseDate), asc(schema.movies.name)],
            "Release Date -": [asc(schema.movies.releaseDate), asc(schema.movies.name)],
            "Re-Watched": [desc(schema.moviesList.redo), asc(schema.movies.name)],
        },
    },
    apiProvider: {
        maxGenres: 5,
    },
    editableFields: [
        "originalName", "name", "directorName", "releaseDate", "duration", "synopsis",
        "budget", "revenue", "tagline", "originalLanguage", "lockStatus", "homepage",
    ],
    tablesForDeletion: [schema.moviesActors, schema.moviesGenre, schema.moviesLabels],
};

================
File: src/lib/server/domain/media/games/games.service.ts
================
import {Status} from "@/lib/server/utils/enums";
import {notFound} from "@tanstack/react-router";
import {saveImageFromUrl} from "@/lib/server/utils/save-image";
import type {DeltaStats} from "@/lib/server/types/stats.types";
import {IGamesService} from "@/lib/server/types/services.types";
import {IProviderService} from "@/lib/server/types/provider.types";
import {IGamesRepository} from "@/lib/server/types/repositories.types";
import {BaseService} from "@/lib/server/domain/media/base/base.service";
import {GamesRepository} from "@/lib/server/domain/media/games/games.repository";
import {Achievement, AchievementData} from "@/lib/server/types/achievements.types";
import {gamesAchievements} from "@/lib/server/domain/media/games/achievements.seed";
import {Game, GamesAchCodeName, GamesList} from "@/lib/server/domain/media/games/games.types";
import {GamesAdvancedStats, MediaAndUserDetails, UserMediaWithLabels} from "@/lib/server/types/base.types";
export class GamesService extends BaseService<
    Game, GamesList, GamesAdvancedStats, GamesAchCodeName, IGamesRepository
> implements IGamesService {
    readonly achievementHandlers: Record<GamesAchCodeName, (achievement: Achievement, userId?: number) => any>;
    constructor(repository: GamesRepository) {
        super(repository);
        this.achievementHandlers = {
            completed_games: this.repository.countCompletedAchievementCte.bind(this.repository),
            rated_games: this.repository.countRatedAchievementCte.bind(this.repository),
            comment_games: this.repository.countCommentedAchievementCte.bind(this.repository),
            hack_slash_games: this.repository.specificGenreAchievementCte.bind(this.repository),
            multiplayer_games: this.repository.getGameModeAchievementCte.bind(this.repository),
            log_hours_games: this.repository.getTimeSpentAchievementCte.bind(this.repository),
            platform_games: this.repository.getPlatformAchievementCte.bind(this.repository),
            pc_games: this.repository.getSpecificPlatformAchievementCte.bind(this.repository),
            short_games: this.repository.getDurationAchievementCte.bind(this.repository),
            long_games: this.repository.getDurationAchievementCte.bind(this.repository),
            developer_games: this.repository.getCompanyAchievementCte.bind(this.repository),
            publisher_games: this.repository.getCompanyAchievementCte.bind(this.repository),
            first_person_games: this.repository.getPerspectiveAchievementCte.bind(this.repository),
        };
    }
    async calculateAdvancedMediaStats(userId?: number) {
        const ratings = await this.repository.computeRatingStats(userId);
        const genresStats = await this.repository.computeTopGenresStats(userId);
        const totalLabels = await this.repository.computeTotalMediaLabel(userId);
        const releaseDates = await this.repository.computeReleaseDateStats(userId);
        const gameModes = await this.repository.gameModesCount(userId);
        const avgDuration = await this.repository.gameAvgPlaytime(userId);
        const durationDistrib = await this.repository.gamePlaytimeDistrib(userId);
        const {
            developersStats,
            publishersStats,
            platformsStats,
            enginesStats,
            perspectivesStats
        } = await this.repository.specificTopMetrics(userId);
        return {
            ratings,
            totalLabels,
            genresStats,
            releaseDates,
            avgDuration,
            durationDistrib,
            gameModes,
            developersStats,
            publishersStats,
            platformsStats,
            enginesStats,
            perspectivesStats,
        } as GamesAdvancedStats;
    }
    async getMediaAndUserDetails(userId: number, mediaId: number | string, external: boolean, providerService: IProviderService) {
        const media = external ?
            await this.repository.findByApiId(mediaId) : await this.repository.findById(mediaId as number);
        let internalMediaId = media?.id;
        if (external && !internalMediaId) {
            internalMediaId = await providerService.fetchAndStoreMediaDetails(mediaId as unknown as number);
            if (!internalMediaId) throw new Error("Failed to fetch media details");
        }
        if (internalMediaId) {
            const mediaWithDetails = await this.repository.findAllAssociatedDetails(internalMediaId);
            if (!mediaWithDetails) throw new Error("Game not found");
            const similarMedia = await this.repository.findSimilarMedia(mediaWithDetails.id)
            const userMedia = await this.repository.findUserMedia(userId, mediaWithDetails.id);
            const followsData = await this.repository.getUserFollowsMediaData(userId, mediaWithDetails.id);
            return {
                media: mediaWithDetails,
                userMedia,
                followsData,
                similarMedia,
            } as MediaAndUserDetails<Game, GamesList>;
        }
        throw new Error("Game not found");
    }
    async getMediaEditableFields(mediaId: number) {
        const media = await this.repository.findById(mediaId);
        if (!media) throw notFound();
        const editableFields = this.repository.config.editableFields;
        const fields: { [key: string]: any } = {};
        for (const key in media) {
            if (Object.prototype.hasOwnProperty.call(media, key) && editableFields.includes(key)) {
                fields[key] = media[key];
            }
        }
        return { fields };
    }
    async updateMediaEditableFields(mediaId: number, payload: Record<string, any>) {
        const media = await this.repository.findById(mediaId);
        if (!media) throw notFound();
        const editableFields = this.repository.config.editableFields;
        const fields: { [key: string]: any } = {};
        fields.apiId = media.apiId;
        if (payload?.imageCover) {
            const imageName = await saveImageFromUrl({
                defaultName: "default.jpg",
                imageUrl: payload.imageCover,
                resize: { width: 300, height: 450 },
                saveLocation: "public/static/covers/games-covers",
            });
            fields.imageCover = imageName;
            delete payload.imageCover;
        }
        for (const key in payload) {
            if (Object.prototype.hasOwnProperty.call(payload, key) && editableFields.includes(key)) {
                fields[key] = payload[key];
            }
        }
        await this.repository.updateMediaWithDetails({ mediaData: fields });
    }
    async getComingNext(userId: number) {
        return this.repository.getComingNext(userId);
    }
    async addMediaToUserList(userId: number, mediaId: number, status?: Status) {
        const newStatus = status ?? this.repository.config.mediaList.defaultStatus;
        const media = await this.repository.findById(mediaId);
        if (!media) throw notFound();
        const userMedia = await this.repository.findUserMedia(userId, mediaId);
        if (userMedia) throw new Error("Media already in your list");
        const newState = await this.repository.addMediaToUserList(userId, media, newStatus);
        const delta = this.calculateDeltaStats(null, newState);
        return { newState, media, delta };
    }
    async updateUserMediaDetails(userId: number, mediaId: number, partialUpdateData: Record<string, any>) {
        const media = await this.repository.findById(mediaId);
        if (!media) throw notFound();
        const oldState = await this.repository.findUserMedia(userId, mediaId);
        if (!oldState) throw new Error("Media not in your list");
        const completeUpdateData = this.completePartialUpdateData(partialUpdateData);
        const newState = await this.repository.updateUserMediaDetails(userId, mediaId, completeUpdateData);
        const delta = this.calculateDeltaStats(oldState, newState);
        return {
            os: oldState,
            ns: newState,
            media,
            delta,
            updateData: completeUpdateData,
        };
    }
    async removeMediaFromUserList(userId: number, mediaId: number) {
        const media = await this.repository.findById(mediaId);
        if (!media) throw notFound();
        const oldState = await this.repository.findUserMedia(userId, mediaId);
        if (!oldState) throw new Error("Media not in your list");
        await this.repository.removeMediaFromUserList(userId, mediaId);
        const delta = this.calculateDeltaStats(oldState, null);
        return delta;
    }
    completePartialUpdateData(partialUpdateData: Record<string, any>, _userMedia?: GamesList) {
        const completeUpdateData = { ...partialUpdateData };
        if (completeUpdateData.status && completeUpdateData.status === Status.PLAN_TO_PLAY) {
            return { ...completeUpdateData, playtime: 0 };
        }
        return completeUpdateData;
    }
    calculateDeltaStats(oldState: UserMediaWithLabels<GamesList> | null, newState: GamesList | null) {
        const delta: DeltaStats = {};
        const statusCounts: Partial<Record<Status, number>> = {};
        const oldStatus = oldState?.status;
        const oldRating = oldState?.rating;
        const oldComment = oldState?.comment;
        const oldFavorite = oldState?.favorite ?? false;
        const oldTotalTimeSpent = oldState?.playtime ?? 0;
        const wasCompleted = oldStatus === Status.COMPLETED;
        const wasFavorited = wasCompleted && oldFavorite;
        const wasCommented = wasCompleted && !!oldComment;
        const wasRated = wasCompleted && oldRating != null;
        const newStatus = newState?.status;
        const newRating = newState?.rating;
        const newComment = newState?.comment;
        const newFavorite = newState?.favorite ?? false;
        const newTotalTimeSpent = newState?.playtime ?? 0;
        const isCompleted = newStatus === Status.COMPLETED;
        const isFavorited = isCompleted && newFavorite;
        const isCommented = isCompleted && !!newComment;
        const isRated = isCompleted && newRating != null;
        if (!oldState && newState) {
            delta.totalEntries = 1;
        }
        else if (oldState && !newState) {
            delta.totalEntries = -1;
        }
        if (oldStatus !== newStatus) {
            if (oldStatus) {
                statusCounts[oldStatus] = (statusCounts[oldStatus] ?? 0) - 1;
            }
            if (newStatus) {
                statusCounts[newStatus] = (statusCounts[newStatus] ?? 0) + 1;
            }
        }
        delta.timeSpent = (newTotalTimeSpent - oldTotalTimeSpent);
        delta.totalRedo = 0;
        delta.totalSpecific = 0;
        let entriesRatedDelta = 0;
        let sumEntriesRatedDelta = 0;
        if (wasRated && !isRated) {
            entriesRatedDelta = -1;
            sumEntriesRatedDelta = -(oldRating ?? 0);
        }
        else if (!wasRated && isRated) {
            entriesRatedDelta = 1;
            sumEntriesRatedDelta = newRating ?? 0;
        }
        else if (wasRated && isRated && oldRating !== newRating) {
            sumEntriesRatedDelta = (newRating ?? 0) - (oldRating ?? 0);
        }
        delta.entriesRated = entriesRatedDelta;
        delta.sumEntriesRated = sumEntriesRatedDelta;
        let entriesCommentedDelta = 0;
        if (wasCommented && !isCommented) {
            entriesCommentedDelta = -1;
        }
        else if (!wasCommented && isCommented) {
            entriesCommentedDelta = 1;
        }
        delta.entriesCommented = entriesCommentedDelta;
        let entriesFavoritesDelta = 0;
        if (wasFavorited && !isFavorited) {
            entriesFavoritesDelta = -1;
        }
        else if (!wasFavorited && isFavorited) {
            entriesFavoritesDelta = 1;
        }
        delta.entriesFavorites = entriesFavoritesDelta;
        if (Object.keys(statusCounts).length > 0) {
            delta.statusCounts = statusCounts;
        }
        return delta;
    }
    getAchievementsDefinition() {
        return gamesAchievements as unknown as AchievementData[];
    }
}

================
File: src/lib/server/domain/media/registries/registries.ts
================
import {MediaType} from "@/lib/server/utils/enums";
import {IProviderService, ITrendsProviderService} from "@/lib/server/types/provider.types";
import {TvRepository} from "@/lib/server/domain/media/tv/tv.repository";
import {GamesRepository} from "@/lib/server/domain/media/games/games.repository";
import {MoviesRepository} from "@/lib/server/domain/media/movies/movies.repository";
import {IGamesService, IMoviesService, ITvService} from "@/lib/server/types/services.types";
export interface MediaRepositoryMap {
    [MediaType.SERIES]: TvRepository;
    [MediaType.ANIME]: TvRepository;
    [MediaType.MOVIES]: MoviesRepository;
    [MediaType.GAMES]: GamesRepository;
    [MediaType.BOOKS]: MoviesRepository;
    [MediaType.MANGA]: MoviesRepository;
}
export interface MediaServiceMap {
    [MediaType.SERIES]: ITvService;
    [MediaType.ANIME]: ITvService;
    [MediaType.MOVIES]: IMoviesService;
    [MediaType.GAMES]: IGamesService;
    [MediaType.BOOKS]: IMoviesService;
    [MediaType.MANGA]: IMoviesService;
}
export interface MediaProviderServiceMap {
    [MediaType.SERIES]: ITrendsProviderService;
    [MediaType.ANIME]: IProviderService;
    [MediaType.MOVIES]: ITrendsProviderService;
    [MediaType.GAMES]: IProviderService;
    [MediaType.BOOKS]: IProviderService;
    [MediaType.MANGA]: IProviderService;
}
export class MediaRepositoryRegistry {
    private static repositories: Partial<MediaRepositoryMap> = {};
    static registerRepository<T extends keyof MediaRepositoryMap>(mediaType: T, repository: MediaRepositoryMap[T]) {
        this.repositories[mediaType] = repository;
    }
    static getRepository<T extends keyof MediaRepositoryMap>(mediaType: T) {
        if (!this.repositories[mediaType]) {
            throw new Error(`Repository for media type ${mediaType} not registered`);
        }
        return this.repositories[mediaType];
    }
}
export class MediaServiceRegistry {
    private static services: Partial<MediaServiceMap> = {};
    static registerService<T extends keyof MediaServiceMap>(mediaType: T, service: MediaServiceMap[T]) {
        this.services[mediaType] = service;
    }
    static getService<T extends keyof MediaServiceMap>(mediaType: T): MediaServiceMap[T] {
        if (!this.services[mediaType]) {
            throw new Error(`Service for media type ${mediaType} not registered`);
        }
        return this.services[mediaType];
    }
}
export class MediaProviderServiceRegistry {
    private static providers: Partial<MediaProviderServiceMap> = {};
    static registerService<T extends keyof MediaProviderServiceMap>(mediaType: T, provider: MediaProviderServiceMap[T]) {
        this.providers[mediaType] = provider;
    }
    static getService<T extends keyof MediaProviderServiceMap>(mediaType: T) {
        if (!this.providers[mediaType]) {
            throw new Error(`ProviderService for media type ${mediaType} not registered`);
        }
        return this.providers[mediaType];
    }
}

================
File: src/lib/server/domain/media/games/games.repository.ts
================
import {db} from "@/lib/server/database/db";
import {notFound} from "@tanstack/react-router";
import {getDbClient} from "@/lib/server/database/async-storage";
import {Achievement} from "@/lib/server/types/achievements.types";
import {IGamesRepository} from "@/lib/server/types/repositories.types";
import {GamesPlatformsEnum, JobType, Status} from "@/lib/server/utils/enums";
import {BaseRepository} from "@/lib/server/domain/media/base/base.repository";
import {AddedMediaDetails, ConfigTopMetric} from "@/lib/server/types/base.types";
import {gamesConfig, GamesSchemaConfig} from "@/lib/server/domain/media/games/games.config";
import {Game, GamesList, UpsertGameWithDetails} from "@/lib/server/domain/media/games/games.types";
import {games, gamesCompanies, gamesGenre, gamesList, gamesPlatforms} from "@/lib/server/database/schema";
import {and, asc, count, countDistinct, eq, getTableColumns, gte, inArray, isNotNull, isNull, like, lte, max, ne, notInArray, or, sql} from "drizzle-orm";
export class GamesRepository extends BaseRepository<Game, GamesList, GamesSchemaConfig> implements IGamesRepository {
    config: GamesSchemaConfig;
    constructor() {
        super(gamesConfig);
        this.config = gamesConfig;
    }
    async getComingNext(userId: number) {
        return getDbClient()
            .select({
                mediaId: games.id,
                mediaName: games.name,
                date: games.releaseDate,
                imageCover: games.imageCover,
            })
            .from(games)
            .innerJoin(gamesList, eq(gamesList.mediaId, games.id))
            .where(and(
                eq(gamesList.userId, userId),
                notInArray(gamesList.status, [Status.DROPPED]),
                gte(games.releaseDate, sql`CURRENT_TIMESTAMP`),
            ))
            .orderBy(asc(games.releaseDate))
            .execute();
    }
    async computeAllUsersStats() {
        const results = await getDbClient()
            .select({
                userId: gamesList.userId,
                timeSpent: sql<number>`COALESCE(SUM(${gamesList.playtime}), 0)`.as("timeSpent"),
                totalSpecific: sql<number>`0`.as("totalSpecific"),
                statusCounts: sql`
                    COALESCE((
                        SELECT
                            JSON_GROUP_OBJECT(status, count_per_status)
                        FROM (
                            SELECT
                                status,
                                COUNT(*) as count_per_status
                            FROM ${gamesList} as sub_list
                            WHERE sub_list.user_id = ${gamesList.userId} GROUP BY status
                        )
                    ), '{}')
                `.as("statusCounts"),
                entriesFavorites: sql<number>`
                    COALESCE(SUM(CASE WHEN ${gamesList.favorite} = 1 THEN 1 ELSE 0 END), 0)
                `.as("entriesFavorites"),
                totalRedo: sql<number>`0`.as("totalRedo"),
                entriesCommented: sql<number>`
                    COALESCE(SUM(CASE WHEN LENGTH(TRIM(COALESCE(${gamesList.comment}, ''))) > 0 THEN 1 ELSE 0 END), 0)
                `.as("entriesCommented"),
                totalEntries: count(gamesList.mediaId).as("totalEntries"),
                entriesRated: count(gamesList.rating).as("entriesRated"),
                sumEntriesRated: sql<number>`COALESCE(SUM(${gamesList.rating}), 0)`.as("sumEntriesRated"),
                averageRating: sql<number>`
                    COALESCE(SUM(${gamesList.rating}) * 1.0 / NULLIF(COUNT(${gamesList.rating}), 0), 0.0)
                `.as("averageRating"),
            })
            .from(gamesList)
            .innerJoin(games, eq(gamesList.mediaId, games.id))
            .groupBy(gamesList.userId)
            .execute();
        return results.map((row) => {
            let statusCounts: Record<string, number> = {};
            try {
                const parsed = typeof row.statusCounts === "string" ? JSON.parse(row.statusCounts) : row.statusCounts;
                if (typeof parsed === "object" && parsed !== null) {
                    statusCounts = parsed;
                }
            }
            catch (e) {
                console.error(`Failed to parse statusCounts for user ${row.userId}:`, row.statusCounts, e);
            }
            return {
                userId: row.userId,
                statusCounts: statusCounts,
                timeSpent: Number(row.timeSpent) || 0,
                totalRedo: Number(row.totalRedo) || 0,
                totalEntries: Number(row.totalEntries) || 0,
                entriesRated: Number(row.entriesRated) || 0,
                totalSpecific: Number(row.totalSpecific) || 0,
                averageRating: Number(row.averageRating) || 0,
                sumEntriesRated: Number(row.sumEntriesRated) || 0,
                entriesFavorites: Number(row.entriesFavorites) || 0,
                entriesCommented: Number(row.entriesCommented) || 0,
            };
        });
    }
    async getMediaToNotify() {
        return getDbClient()
            .select({
                mediaId: games.id,
                mediaName: games.name,
                releaseDate: games.releaseDate,
                userId: gamesList.userId,
            })
            .from(games)
            .innerJoin(gamesList, eq(gamesList.mediaId, games.id))
            .where(and(
                isNotNull(games.releaseDate),
                gte(games.releaseDate, sql`datetime('now')`),
                lte(games.releaseDate, sql`datetime('now', '+7 days')`),
            ))
            .orderBy(games.releaseDate)
            .execute();
    }
    async addMediaToUserList(userId: number, media: Game, newStatus: Status) {
        const [newMedia] = await getDbClient()
            .insert(gamesList)
            .values({ userId, mediaId: media.id, status: newStatus, playtime: 0 })
            .returning();
        return newMedia;
    }
    async getMediaJobDetails(userId: number, job: JobType, name: string, offset: number, limit = 25) {
        let dataQuery = getDbClient()
            .selectDistinct({
                mediaId: games.id,
                mediaName: games.name,
                imageCover: games.imageCover,
                inUserList: isNotNull(gamesList.userId).mapWith(Boolean).as("inUserList"),
            })
            .from(games)
            .leftJoin(gamesList, and(eq(gamesList.mediaId, games.id), eq(gamesList.userId, userId)))
            .$dynamic();
        let countQuery = getDbClient()
            .select({ value: countDistinct(games.id) })
            .from(games)
            .$dynamic();
        let filterConditions: any[] = [];
        if (job === JobType.CREATOR) {
            dataQuery = dataQuery.innerJoin(gamesCompanies, eq(gamesCompanies.mediaId, games.id));
            countQuery = countQuery.innerJoin(gamesCompanies, eq(gamesCompanies.mediaId, games.id));
            filterConditions = [like(gamesCompanies.name, `%${name}%`), eq(gamesCompanies.developer, true)];
        }
        else {
            throw notFound();
        }
        if (filterConditions.length > 0) {
            dataQuery = dataQuery.where(and(...filterConditions));
            countQuery = countQuery.where(and(...filterConditions));
        }
        const [totalResult, results] = await Promise.all([
            countQuery.execute(),
            dataQuery.orderBy(asc(games.releaseDate)).limit(limit).offset(offset).execute(),
        ]);
        const totalCount = totalResult[0]?.value ?? 0;
        return { items: results, total: totalCount, pages: Math.ceil(totalCount / limit) };
    }
    async getMediaIdsToBeRefreshed() {
        const results = await getDbClient()
            .select({ apiId: games.apiId })
            .from(games)
            .where(and(
                lte(games.lastApiUpdate, sql`datetime(CURRENT_TIMESTAMP, '-6 days')`),
                or(gte(games.releaseDate, sql`CURRENT_TIMESTAMP`), isNull(games.releaseDate))
            ));
        return results.map((r) => r.apiId);
    }
    async findAllAssociatedDetails(mediaId: number) {
        const details = await getDbClient()
            .select({
                ...getTableColumns(games),
                genres: sql`json_group_array(DISTINCT json_object('id', ${gamesGenre.id}, 'name', ${gamesGenre.name}))`.mapWith(JSON.parse),
                companies: sql`json_group_array(DISTINCT json_object('id', ${gamesCompanies.id}, 'name', ${gamesCompanies.name}, 'developer', ${gamesCompanies.developer}, 'publisher', ${gamesCompanies.publisher}))`.mapWith(JSON.parse),
                platforms: sql`json_group_array(DISTINCT json_object('id', ${gamesPlatforms.id}, 'name', ${gamesPlatforms.name}))`.mapWith(JSON.parse),
            })
            .from(games)
            .innerJoin(gamesCompanies, eq(gamesCompanies.mediaId, games.id))
            .innerJoin(gamesPlatforms, eq(gamesPlatforms.mediaId, games.id))
            .innerJoin(gamesGenre, eq(gamesGenre.mediaId, games.id))
            .where(eq(games.id, mediaId))
            .groupBy(...Object.values(getTableColumns(games)))
            .get();
        if (!details) return;
        const result: Game & AddedMediaDetails = {
            ...details,
            genres: details.genres || [],
            companies: details.companies || [],
            platforms: details.platforms || [],
        };
        return result;
    }
    async storeMediaWithDetails({ mediaData, companiesData, platformsData, genresData }: UpsertGameWithDetails) {
        const result = await db.transaction(async (tx) => {
            const [media] = await tx
                .insert(games)
                .values(mediaData)
                .returning()
            if (!media) return;
            const mediaId = media.id;
            if (companiesData && companiesData.length > 0) {
                const companiesToAdd = companiesData.map((comp) => ({ mediaId, ...comp }));
                await tx.insert(gamesCompanies).values(companiesToAdd)
            }
            if (platformsData && platformsData.length > 0) {
                const platformsToAdd = platformsData.map((plt) => ({ mediaId, name: plt.name }));
                await tx.insert(gamesPlatforms).values(platformsToAdd)
            }
            if (genresData && genresData.length > 0) {
                const genresToAdd = genresData.map((g) => ({ mediaId, name: g.name }));
                await tx.insert(gamesGenre).values(genresToAdd)
            }
            return mediaId;
        });
        return result;
    }
    async updateMediaWithDetails({ mediaData, companiesData, platformsData, genresData }: UpsertGameWithDetails) {
        const tx = getDbClient();
        const [media] = await tx
            .update(games)
            .set({ ...mediaData, lastApiUpdate: sql`CURRENT_TIMESTAMP` })
            .where(eq(games.apiId, mediaData.apiId))
            .returning({ id: games.id })
        const mediaId = media.id;
        if (companiesData && companiesData.length > 0) {
            await tx.delete(gamesCompanies).where(eq(gamesCompanies.mediaId, mediaId));
            const companiesToAdd = companiesData.map((comp) => ({ mediaId, ...comp }));
            await tx.insert(gamesCompanies).values(companiesToAdd)
        }
        if (platformsData && platformsData.length > 0) {
            await tx.delete(gamesPlatforms).where(eq(gamesPlatforms.mediaId, mediaId));
            const platformsToAdd = platformsData.map((plt) => ({ mediaId, name: plt.name }));
            await tx.insert(gamesPlatforms).values(platformsToAdd)
        }
        if (genresData && genresData.length > 0) {
            await tx.delete(gamesGenre).where(eq(gamesGenre.mediaId, mediaId));
            const genresToAdd = genresData.map((g) => ({ mediaId, name: g.name }));
            await tx.insert(gamesGenre).values(genresToAdd)
        }
        return true;
    }
    async getListFilters(userId: number) {
        const { genres, labels } = await super.getCommonListFilters(userId);
        const platforms = await getDbClient()
            .selectDistinct({ name: sql<GamesPlatformsEnum>`${gamesList.platform}` })
            .from(gamesList)
            .where(and(eq(gamesList.userId, userId), isNotNull(gamesList.platform)));
        return { platforms, genres, labels };
    }
    async getSearchListFilters(userId: number, query: string, job: JobType) {
        if (job === JobType.CREATOR) {
            const companies = await getDbClient()
                .selectDistinct({ name: gamesCompanies.name })
                .from(gamesCompanies)
                .innerJoin(gamesList, eq(gamesList.mediaId, gamesCompanies.mediaId))
                .where(and(eq(gamesList.userId, userId), like(gamesCompanies.name, `%${query}%`)));
            return companies
        }
        else {
            throw notFound();
        }
    }
    getGameModeAchievementCte(achievement: Achievement, userId?: number) {
        let baseCTE = getDbClient()
            .select({
                userId: gamesList.userId,
                value: count(gamesList.id).as("value"),
            }).from(gamesList)
            .innerJoin(games, eq(gamesList.mediaId, games.id))
        const conditions = [
            like(games.gameModes, `%${achievement.value}%`),
            notInArray(gamesList.status, [Status.DROPPED, Status.PLAN_TO_PLAY]),
        ]
        return this.applyWhereConditionsAndGrouping(baseCTE, conditions, userId);
    }
    getTimeSpentAchievementCte(_achievement: Achievement, userId?: number) {
        let baseCTE = getDbClient()
            .select({
                userId: gamesList.userId,
                value: sql`SUM(${gamesList.playtime}) / 60`.as("value"),
            }).from(gamesList)
        return this.applyWhereConditionsAndGrouping(baseCTE, [], userId);
    }
    getPlatformAchievementCte(_achievement: Achievement, userId?: number) {
        let baseCTE = getDbClient()
            .select({
                userId: gamesList.userId,
                value: countDistinct(gamesList.platform).as("value"),
            }).from(gamesList)
        const conditions = [notInArray(gamesList.status, [Status.DROPPED, Status.PLAN_TO_PLAY])]
        return this.applyWhereConditionsAndGrouping(baseCTE, conditions, userId);
    }
    getSpecificPlatformAchievementCte(achievement: Achievement, userId?: number) {
        let baseCTE = getDbClient()
            .select({
                userId: gamesList.userId,
                value: count(gamesList.mediaId).as("value"),
            }).from(gamesList)
        const conditions = [
            eq(gamesList.platform, achievement.value as GamesPlatformsEnum),
            notInArray(gamesList.status, [Status.DROPPED, Status.PLAN_TO_PLAY]),
        ]
        return this.applyWhereConditionsAndGrouping(baseCTE, conditions, userId);
    }
    getDurationAchievementCte(achievement: Achievement, userId?: number) {
        const value = parseInt(achievement.value!);
        const isLong = achievement.codeName.includes("long");
        let baseCTE = getDbClient()
            .select({
                userId: gamesList.userId,
                value: count(gamesList.mediaId).as("value"),
            }).from(gamesList)
            .innerJoin(games, eq(gamesList.mediaId, games.id))
        const conditions = [
            isLong ? gte(gamesList.playtime, value) : lte(gamesList.playtime, value),
            inArray(gamesList.status, [Status.PLAYING, Status.COMPLETED, Status.ENDLESS, Status.MULTIPLAYER]),
        ]
        return this.applyWhereConditionsAndGrouping(baseCTE, conditions, userId);
    }
    getCompanyAchievementCte(achievement: Achievement, userId?: number) {
        const isDevCompany = achievement.value = "developer";
        let subQ = getDbClient()
            .select({
                userId: gamesList.userId,
                count: count(gamesList.mediaId).as("count"),
            }).from(gamesList)
            .innerJoin(gamesCompanies, eq(gamesList.mediaId, gamesCompanies.mediaId))
            .where(and(
                notInArray(gamesList.status, [Status.DROPPED, Status.PLAN_TO_PLAY]),
                isDevCompany ? eq(gamesCompanies.developer, true) : eq(gamesCompanies.publisher, true)
            ))
            .groupBy(userId ? eq(gamesList.userId, userId) : gamesList.userId, gamesCompanies.name)
            .as("sub");
        return getDbClient()
            .select({
                userId: subQ.userId,
                value: max(subQ.count).as("value"),
            }).from(subQ)
            .groupBy(subQ.userId)
            .as("calculation");
    }
    getPerspectiveAchievementCte(achievement: Achievement, userId?: number) {
        let baseCTE = getDbClient()
            .select({
                userId: gamesList.userId,
                value: count(gamesList.mediaId).as("value"),
            }).from(gamesList)
            .innerJoin(games, eq(gamesList.mediaId, games.id))
        const conditions = [
            eq(games.playerPerspective, achievement.value as string),
            notInArray(gamesList.status, [Status.DROPPED, Status.PLAN_TO_PLAY]),
        ]
        return this.applyWhereConditionsAndGrouping(baseCTE, conditions, userId);
    }
    async gameAvgPlaytime(userId?: number) {
        const forUser = userId ? eq(gamesList.userId, userId) : undefined;
        const avgDuration = await getDbClient()
            .select({
                average: sql<number | null>`avg(${gamesList.playtime})`.as("avg_playtime")
            })
            .from(gamesList)
            .where(and(forUser, ne(gamesList.status, Status.PLAN_TO_PLAY), isNotNull(gamesList.playtime)))
            .get();
        return avgDuration?.average;
    }
    async gamePlaytimeDistrib(userId?: number) {
        const forUser = userId ? eq(gamesList.userId, userId) : undefined;
        return getDbClient()
            .select({
                name: sql<number>`floor(log2(greatest(${gamesList.playtime} / 60, 1)))`,
                value: count(games.id).as("count"),
            })
            .from(games)
            .innerJoin(gamesList, eq(gamesList.mediaId, games.id))
            .where(and(forUser, ne(gamesList.status, Status.PLAN_TO_PLAY), isNotNull(gamesList.playtime)))
            .groupBy(sql<number>`floor(log2(greatest(${gamesList.playtime} / 60, 1)))`)
            .orderBy(asc(sql<number>`floor(log2(greatest(${gamesList.playtime} / 60, 1)))`));
    }
    async specificTopMetrics(userId?: number) {
        const developersConfig: ConfigTopMetric = {
            metricIdColumn: games.id,
            metricTable: gamesCompanies,
            mediaLinkColumn: gamesList.mediaId,
            metricNameColumn: gamesCompanies.name,
            filters: [ne(gamesList.status, Status.PLAN_TO_PLAY), eq(gamesCompanies.developer, true)],
        };
        const publishersConfig: ConfigTopMetric = {
            ...developersConfig,
            filters: [ne(gamesList.status, Status.PLAN_TO_PLAY), eq(gamesCompanies.publisher, true)],
        };
        const platformsConfig: ConfigTopMetric = {
            metricTable: gamesList,
            metricNameColumn: gamesList.platform,
            metricIdColumn: games.id,
            mediaLinkColumn: gamesList.mediaId,
            filters: [ne(gamesList.status, Status.PLAN_TO_PLAY)],
        };
        const enginesConfig: ConfigTopMetric = {
            metricTable: games,
            metricNameColumn: games.gameEngine,
            metricIdColumn: games.id,
            mediaLinkColumn: gamesList.mediaId,
            filters: [ne(gamesList.status, Status.PLAN_TO_PLAY)],
        };
        const perspectivesConfig: ConfigTopMetric = {
            metricTable: games,
            metricNameColumn: games.playerPerspective,
            metricIdColumn: games.id,
            mediaLinkColumn: gamesList.mediaId,
            filters: [ne(gamesList.status, Status.PLAN_TO_PLAY)],
        };
        const developersStats = await this.computeTopMetricStats(developersConfig, userId);
        const publishersStats = await this.computeTopMetricStats(publishersConfig, userId);
        const platformsStats = await this.computeTopMetricStats(platformsConfig, userId);
        const enginesStats = await this.computeTopMetricStats(enginesConfig, userId);
        const perspectivesStats = await this.computeTopMetricStats(perspectivesConfig, userId);
        return { developersStats, publishersStats, platformsStats, enginesStats, perspectivesStats };
    }
    async gameModesCount(userId?: number) {
        const forUser = userId ? eq(gamesList.userId, userId) : undefined;
        const data = await getDbClient()
            .select({ modes: games.gameModes })
            .from(games)
            .innerJoin(gamesList, eq(gamesList.mediaId, games.id))
            .where(and(forUser, ne(gamesList.status, Status.PLAN_TO_PLAY), isNotNull(games.gameModes)))
            .execute();
        const gameModes = data.flatMap(r => (r.modes ? r.modes.split(",") : []));
        const modeCounts: Record<string, number> = {};
        for (const mode of gameModes) {
            modeCounts[mode] = (modeCounts[mode] || 0) + 1;
        }
        const topValuesResult = Object.entries(modeCounts)
            .map(([name, value]) => ({ name, value: Number(value) || 0 }));
        return { topValues: topValuesResult };
    }
}

================
File: src/lib/server/types/services.types.ts
================
import {Label} from "@/lib/components/types";
import {DeltaStats} from "@/lib/server/types/stats.types";
import {IProviderService} from "@/lib/server/types/provider.types";
import {JobType, MediaType, Status} from "@/lib/server/utils/enums";
import {TvList, TvType} from "@/lib/server/domain/media/tv/tv.types";
import {Game, GamesList} from "@/lib/server/domain/media/games/games.types";
import {Movie, MoviesList} from "@/lib/server/domain/media/movies/movies.types";
import {Achievement, AchievementData} from "@/lib/server/types/achievements.types";
import {
    AddMediaToUserList,
    ComingNext,
    EditUserLabels,
    ExpandedListFilters,
    GamesAdvancedStats,
    ItemForNotification,
    JobDetails,
    MediaAndUserDetails,
    MediaListArgs,
    MediaListData,
    MoviesAdvancedStats,
    SearchType,
    TvAdvancedStats,
    UpdateUserMediaDetails,
    UserMediaStats,
    UserMediaWithLabels
} from "@/lib/server/types/base.types";
export interface IUniversalService<TMedia, TList> {
    getCoverFilenames(): Promise<string[]>;
    getNonListMediaIds(): Promise<number[]>;
    computeAllUsersStats(): Promise<UserMediaStats[]>;
    getMediaToNotify(): Promise<ItemForNotification[]>;
    removeMediaByIds(mediaIds: number[]): Promise<void>;
    findById(mediaId: number): Promise<TMedia | undefined>;
    computeTotalMediaLabel(userId?: number): Promise<number>;
    getListFilters(userId: number): Promise<ExpandedListFilters>;
    getUserMediaLabels(userId: number): Promise<{ name: string }[]>;
    getAchievementCte(achievement: Achievement, userId?: number): any;
    editUserLabel(args: EditUserLabels): Promise<Label | void | undefined>;
    searchByName(query: string, limit?: number): Promise<{ name: string }[]>;
    downloadMediaListAsCSV(userId: number): Promise<(TMedia & { mediaName: string })[] | undefined>;
    getSearchListFilters(userId: number, query: string, job: JobType): Promise<{ name: string | null }[]>;
    getMediaJobDetails(userId: number, job: JobType, name: string, search: SearchType): Promise<JobDetails>;
    getMediaList(currentUserId: number | undefined, userId: number, args: MediaListArgs): Promise<MediaListData<TList>>;
}
export interface ICommonService<TMedia, TList, TStats> extends IUniversalService<TMedia, TList> {
    calculateAdvancedMediaStats(userId?: number): Promise<TStats>;
    getAchievementsDefinition(mediaType?: MediaType): AchievementData[];
    removeMediaFromUserList(userId: number, mediaId: number): Promise<DeltaStats>;
    getMediaEditableFields(mediaId: number): Promise<{ fields: Record<string, any> }>
    updateMediaEditableFields(mediaId: number, payload: Record<string, any>): Promise<void>;
    calculateDeltaStats(oldState: UserMediaWithLabels<TList>, newState: TList, media: TMedia): DeltaStats;
    completePartialUpdateData(partialUpdateData: Record<string, any>, userMedia?: TList): Record<string, any>;
    addMediaToUserList(userId: number, mediaId: number, newStatus?: Status): Promise<AddMediaToUserList<TMedia, TList>>;
    updateUserMediaDetails(userId: number, mediaId: number, updateData: Record<string, any>): Promise<UpdateUserMediaDetails<TMedia, TList>>;
    getMediaAndUserDetails(userId: number, mediaId: number | string, external: boolean, providerService: IProviderService): Promise<MediaAndUserDetails<TMedia, TList>>;
}
export interface IMoviesService extends ICommonService<Movie, MoviesList, MoviesAdvancedStats> {
    lockOldMovies(): Promise<number>;
    getComingNext(userId: number): Promise<ComingNext[]>;
}
export interface ITvService extends ICommonService<TvType, TvList, TvAdvancedStats> {
    getComingNext(userId: number): Promise<ComingNext[]>;
}
export interface IGamesService extends ICommonService<Game, GamesList, GamesAdvancedStats> {
    getComingNext(userId: number): Promise<ComingNext[]>;
}
export type MediaService = IMoviesService | ITvService | IGamesService;

================
File: src/lib/server/types/repositories.types.ts
================
import {SQL} from "drizzle-orm";
import {JobType, Status} from "@/lib/server/utils/enums";
import {Achievement} from "@/lib/server/types/achievements.types";
import {GamesSchemaConfig} from "@/lib/server/domain/media/games/games.config";
import {MovieSchemaConfig} from "@/lib/server/domain/media/movies/movies.config";
import {AnimeSchemaConfig} from "@/lib/server/domain/media/tv/anime/anime.config";
import {SeriesSchemaConfig} from "@/lib/server/domain/media/tv/series/series.config";
import {TvList, TvTopMetricStats, TvType} from "@/lib/server/domain/media/tv/tv.types";
import {Game, GamesList, GamesTopMetricStats} from "@/lib/server/domain/media/games/games.types";
import {Movie, MoviesList, MoviesTopMetricStats, UpsertMovieWithDetails} from "@/lib/server/domain/media/movies/movies.types";
import {
    AddedMediaDetails,
    ComingNext,
    CommonListFilters,
    ConfigTopMetric,
    EditUserLabels,
    EpsPerSeasonType,
    ExpandedListFilters,
    ItemForNotification,
    JobDetails,
    MediaListArgs,
    MediaListData,
    SimpleMedia,
    TopMetricStats,
    UserFollowsMediaData,
    UserMediaStats,
    UserMediaWithLabels
} from "@/lib/server/types/base.types";
import {Label} from "@/lib/components/types";
export interface IUniversalRepository<TMedia, TList> {
    getNonListMediaIds(): Promise<number[]>;
    removeMediaByIds(mediaIds: number[]): Promise<void>;
    findById(mediaId: number): Promise<TMedia | undefined>;
    getCoverFilenames(): Promise<{ imageCover: string }[]>;
    computeTotalMediaLabel(userId?: number): Promise<number>;
    findSimilarMedia(mediaId: number): Promise<SimpleMedia[]>;
    getUserMediaLabels(userId: number): Promise<{ name: string }[]>;
    findByApiId(apiId: number | string): Promise<TMedia | undefined>;
    getCommonListFilters(userId: number): Promise<CommonListFilters>;
    editUserLabel(args: EditUserLabels): Promise<Label | undefined | void>;
    removeMediaFromUserList(userId: number, mediaId: number): Promise<void>;
    searchByName(query: string, limit?: number): Promise<{ name: string }[]>;
    getUserFavorites(userId: number, limit?: number): Promise<SimpleMedia[]>;
    findUserMedia(userId: number, mediaId: number): Promise<UserMediaWithLabels<TList> | null>;
    downloadMediaListAsCSV(userId: number): Promise<(TMedia & { mediaName: string })[] | undefined>;
    getUserFollowsMediaData(userId: number, mediaId: number): Promise<UserFollowsMediaData<TList>[]>;
    updateUserMediaDetails(userId: number, mediaId: number, updateData: Partial<TList>): Promise<TList>;
    getMediaList(currentUserId: number | undefined, userId: number, args: MediaListArgs): Promise<MediaListData<TList>>;
    countRatedAchievementCte(achievement: Achievement, userId?: number): Promise<any>;
    specificGenreAchievementCte(achievement: Achievement, userId?: number): Promise<any>;
    countCompletedAchievementCte(achievement: Achievement, userId?: number): Promise<any>;
    countCommentedAchievementCte(achievement: Achievement, userId?: number): Promise<any>;
    applyWhereConditionsAndGrouping(cte: any, baseConditions: SQL[], userId?: number): any;
    computeTotalMediaLabel(userId?: number): Promise<number>;
    computeTopGenresStats(userId?: number): Promise<TopMetricStats>;
    computeRatingStats(userId?: number): Promise<{ name: string, value: number }[]>;
    computeReleaseDateStats(userId?: number): Promise<{ name: number, value: number }[]>;
    computeTopMetricStats(statsConfig: ConfigTopMetric, userId?: number): Promise<TopMetricStats>;
}
export interface ICommonRepository<TMedia, TList> extends IUniversalRepository<TMedia, TList> {
    computeAllUsersStats(): Promise<UserMediaStats[]>;
    getMediaToNotify(): Promise<ItemForNotification[]>;
    getListFilters(userId: number): Promise<ExpandedListFilters>;
    addMediaToUserList(userId: number, media: TMedia, newStatus: Status): Promise<TList>;
    findAllAssociatedDetails(mediaId: number): Promise<(TMedia & AddedMediaDetails) | undefined>;
    getSearchListFilters(userId: number, query: string, job: JobType): Promise<{ name: string | null }[]>;
    getMediaJobDetails(userId: number, job: JobType, name: string, offset: number, limit?: number): Promise<JobDetails>;
}
export interface IMoviesRepository extends ICommonRepository<Movie, MoviesList> {
    config: MovieSchemaConfig;
    lockOldMovies(): Promise<number>;
    getMediaIdsToBeRefreshed(): Promise<number[]>;
    getComingNext(userId: number): Promise<ComingNext[]>;
    updateMediaWithDetails({ mediaData, actorsData, genresData }: UpsertMovieWithDetails): Promise<boolean>;
    storeMediaWithDetails({ mediaData, actorsData, genresData }: UpsertMovieWithDetails): Promise<number | undefined>;
    getActorAchievementCte(_achievement: Achievement, userId?: number): any;
    getDurationAchievementCte(achievement: Achievement, userId?: number): any;
    getDirectorAchievementCte(_achievement: Achievement, userId?: number): any;
    getLanguageAchievementCte(achievement: Achievement, userId?: number): any;
    specificTopMetrics(userId?: number): Promise<MoviesTopMetricStats>;
    avgMovieDuration(userId?: number): Promise<number | null | undefined>;
    movieDurationDistrib(userId?: number): Promise<{ name: number, value: number }[]>;
    budgetRevenueStats(userId?: number): Promise<{ totalBudget: number | undefined, totalRevenue: number | undefined }>;
}
export interface ITvRepository extends ICommonRepository<TvType, TvList> {
    config: SeriesSchemaConfig | AnimeSchemaConfig;
    getComingNext(userId: number): Promise<ComingNext[]>;
    findByIdAndAddEpsPerSeason(mediaId: number): Promise<TvType>;
    getMediaIdsToBeRefreshed(apiIds: number[]): Promise<number[]>;
    getMediaEpsPerSeason(mediaId: number): Promise<EpsPerSeasonType>;
    updateMediaWithDetails({ mediaData, actorsData, genresData }: any): Promise<boolean>;
    storeMediaWithDetails({ mediaData, actorsData, genresData }: any): Promise<number | undefined>;
    getDurationAchievementCte(achievement: Achievement, userId?: number): any;
    getNetworkAchievementCte(achievement: Achievement, userId?: number): any;
    getActorAchievementCte(achievement: Achievement, userId?: number): any;
    specificTopMetrics(userId?: number): Promise<TvTopMetricStats>;
    computeTotalSeasons(userId?: number): Promise<number | undefined>;
    avgTvDuration(userId?: number): Promise<number | null | undefined>;
    tvDurationDistrib(userId?: number): Promise<{ name: number, value: number }[]>;
}
export interface IGamesRepository extends ICommonRepository<Game, GamesList> {
    config: GamesSchemaConfig;
    getMediaIdsToBeRefreshed(): Promise<number[]>;
    getComingNext(userId: number): Promise<ComingNext[]>;
    updateMediaWithDetails({ mediaData, actorsData, genresData }: any): Promise<boolean>;
    storeMediaWithDetails({ mediaData, actorsData, genresData }: any): Promise<number | undefined>;
    getCompanyAchievementCte(achievement: Achievement, userId?: number): any;
    getDurationAchievementCte(achievement: Achievement, userId?: number): any;
    getGameModeAchievementCte(achievement: Achievement, userId?: number): any;
    getPlatformAchievementCte(achievement: Achievement, userId?: number): any;
    getTimeSpentAchievementCte(achievement: Achievement, userId?: number): any;
    getPerspectiveAchievementCte(achievement: Achievement, userId?: number): any;
    getSpecificPlatformAchievementCte(achievement: Achievement, userId?: number): any;
    specificTopMetrics(userId?: number): Promise<GamesTopMetricStats>;
    gameAvgPlaytime(userId?: number): Promise<number | null | undefined>;
    gamePlaytimeDistrib(userId?: number): Promise<{ name: number, value: number }[]>;
    gameModesCount(userId?: number): Promise<{ topValues: { name: string, value: number }[] }>;
}

================
File: src/lib/server/domain/media/tv/tv.repository.ts
================
import {db} from "@/lib/server/database/db";
import {notFound} from "@tanstack/react-router";
import {JobType, Status} from "@/lib/server/utils/enums";
import {getDbClient} from "@/lib/server/database/async-storage";
import {Achievement} from "@/lib/server/types/achievements.types";
import {ITvRepository} from "@/lib/server/types/repositories.types";
import {BaseRepository} from "@/lib/server/domain/media/base/base.repository";
import {AnimeSchemaConfig} from "@/lib/server/domain/media/tv/anime/anime.config";
import {SeriesSchemaConfig} from "@/lib/server/domain/media/tv/series/series.config";
import {TvList, TvType, UpsertTvWithDetails} from "@/lib/server/domain/media/tv/tv.types";
import {AddedMediaDetails, ConfigTopMetric, EpsPerSeasonType} from "@/lib/server/types/base.types";
import {and, asc, count, countDistinct, eq, getTableColumns, gte, inArray, isNotNull, like, lte, max, ne, notInArray, sql} from "drizzle-orm";
export class TvRepository extends BaseRepository<TvType, TvList, SeriesSchemaConfig | AnimeSchemaConfig> implements ITvRepository {
    config: SeriesSchemaConfig | AnimeSchemaConfig;
    constructor(config: SeriesSchemaConfig | AnimeSchemaConfig) {
        super(config);
        this.config = config;
    }
    async findByIdAndAddEpsPerSeason(mediaId: number) {
        const { mediaTable, epsPerSeasonTable } = this.config;
        const mainData = await getDbClient()
            .select({
                ...getTableColumns(mediaTable),
                epsPerSeason: sql<EpsPerSeasonType>`json_group_array(json_object(
                    'season', ${epsPerSeasonTable.season},
                    'episodes', ${epsPerSeasonTable.episodes}
                ))`.mapWith(JSON.parse),
            })
            .from(mediaTable)
            .innerJoin(epsPerSeasonTable, eq(epsPerSeasonTable.mediaId, mediaTable.id))
            .where(eq(mediaTable.id, mediaId))
            .get();
        return mainData as TvType;
    }
    async getComingNext(userId: number) {
        const { mediaTable, listTable } = this.config;
        const comingNext = await getDbClient()
            .select({
                mediaId: mediaTable.id,
                mediaName: mediaTable.name,
                date: mediaTable.nextEpisodeToAir,
                imageCover: mediaTable.imageCover,
                seasonToAir: mediaTable.seasonToAir,
                episodeToAir: mediaTable.episodeToAir,
            })
            .from(mediaTable)
            .innerJoin(listTable, eq(listTable.mediaId, mediaTable.id))
            .where(and(
                eq(listTable.userId, userId),
                notInArray(listTable.status, [Status.DROPPED, Status.RANDOM]),
                gte(mediaTable.nextEpisodeToAir, sql`CURRENT_TIMESTAMP`),
            ))
            .orderBy(asc(mediaTable.nextEpisodeToAir))
            .execute();
        return comingNext;
    }
    async computeAllUsersStats() {
        const { mediaTable, listTable } = this.config;
        const results = await getDbClient()
            .select({
                userId: listTable.userId,
                timeSpent: sql<number>`COALESCE(SUM(${listTable.total} * ${mediaTable.duration}), 0)`.as("timeSpent"),
                totalSpecific: sql<number>`COALESCE(SUM(${listTable.total}), 0)`.as("totalSpecific"),
                statusCounts: sql`
                    COALESCE((
                        SELECT
                            JSON_GROUP_OBJECT(status, count_per_status)
                        FROM (
                            SELECT
                                status,
                                COUNT(*) as count_per_status
                            FROM ${listTable} as sub_list
                            WHERE sub_list.user_id = ${listTable.userId} GROUP BY status
                        )
                    ), '{}')
                `.as("statusCounts"),
                entriesFavorites: sql<number>`
                    COALESCE(SUM(CASE WHEN ${listTable.favorite} = 1 THEN 1 ELSE 0 END), 0)
                `.as("entriesFavorites"),
                totalRedo: sql<number>`COALESCE(SUM(${listTable.redo}), 0)`.as("totalRedo"),
                entriesCommented: sql<number>`
                    COALESCE(SUM(CASE WHEN LENGTH(TRIM(COALESCE(${listTable.comment}, ''))) > 0 THEN 1 ELSE 0 END), 0)
                `.as("entriesCommented"),
                totalEntries: count(listTable.mediaId).as("totalEntries"),
                entriesRated: count(listTable.rating).as("entriesRated"),
                sumEntriesRated: sql<number>`COALESCE(SUM(${listTable.rating}), 0)`.as("sumEntriesRated"),
                averageRating: sql<number>`
                    COALESCE(SUM(${listTable.rating}) * 1.0 / NULLIF(COUNT(${listTable.rating}), 0), 0.0)
                `.as("averageRating"),
            })
            .from(listTable)
            .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id))
            .groupBy(listTable.userId)
            .execute();
        return results.map((row) => {
            let statusCounts: Record<string, number> = {};
            try {
                const parsed = typeof row.statusCounts === "string" ? JSON.parse(row.statusCounts) : row.statusCounts;
                if (typeof parsed === "object" && parsed !== null) {
                    statusCounts = parsed;
                }
            }
            catch (e) {
                console.error(`Failed to parse statusCounts for user ${row.userId}:`, row.statusCounts, e);
            }
            return {
                userId: row.userId,
                statusCounts: statusCounts,
                timeSpent: Number(row.timeSpent) || 0,
                totalRedo: Number(row.totalRedo) || 0,
                totalEntries: Number(row.totalEntries) || 0,
                entriesRated: Number(row.entriesRated) || 0,
                totalSpecific: Number(row.totalSpecific) || 0,
                averageRating: Number(row.averageRating) || 0,
                sumEntriesRated: Number(row.sumEntriesRated) || 0,
                entriesFavorites: Number(row.entriesFavorites) || 0,
                entriesCommented: Number(row.entriesCommented) || 0,
            };
        });
    }
    async getMediaToNotify() {
        const { mediaTable, listTable, epsPerSeasonTable } = this.config;
        const epsSubq = getDbClient()
            .select({
                mediaId: epsPerSeasonTable.mediaId,
                maxSeason: max(epsPerSeasonTable.season).as("maxSeason"),
                lastEpisode: max(epsPerSeasonTable.episodes).as("lastEpisode"),
            }).from(epsPerSeasonTable)
            .groupBy(epsPerSeasonTable.mediaId)
            .as("epsSubq");
        return getDbClient()
            .select({
                mediaId: mediaTable.id,
                userId: listTable.userId,
                mediaName: mediaTable.name,
                lastEpisode: epsSubq.lastEpisode,
                seasonToAir: mediaTable.seasonToAir,
                episodeToAir: mediaTable.episodeToAir,
                releaseDate: mediaTable.nextEpisodeToAir,
            })
            .from(mediaTable)
            .innerJoin(listTable, eq(listTable.mediaId, mediaTable.id))
            .innerJoin(epsSubq, eq(mediaTable.id, epsSubq.mediaId))
            .where(and(
                isNotNull(mediaTable.nextEpisodeToAir),
                gte(mediaTable.releaseDate, sql`datetime('now')`),
                lte(mediaTable.releaseDate, sql`datetime('now', '+7 days')`),
            ))
            .orderBy(mediaTable.nextEpisodeToAir)
            .execute();
    }
    async addMediaToUserList(userId: number, media: TvType, newStatus: Status) {
        const { listTable } = this.config;
        let newTotal = 1;
        let newSeason = 1;
        let newEpisode = 1;
        if (newStatus === Status.COMPLETED) {
            newSeason = media.epsPerSeason![-1].season;
            newEpisode = media.epsPerSeason![-1].episodes;
            newTotal = media.epsPerSeason!.reduce((acc: number, curr: any) => acc + curr.episodes, 0);
        }
        else if (newStatus === Status.PLAN_TO_WATCH || newStatus === Status.RANDOM) {
            newTotal = 0;
            newEpisode = 0;
        }
        const [newMedia] = await getDbClient()
            .insert(listTable)
            .values({
                userId,
                mediaId: media.id,
                currentSeason: newSeason,
                lastEpisodeWatched: newEpisode,
                total: newTotal,
                status: newStatus,
                redo2: Array(media.epsPerSeason!.length).fill(0),
            })
            .returning();
        return newMedia;
    }
    async getMediaEpsPerSeason(mediaId: number) {
        const { epsPerSeasonTable } = this.config;
        return getDbClient()
            .select({
                season: epsPerSeasonTable.season,
                episodes: epsPerSeasonTable.episodes,
            })
            .from(epsPerSeasonTable)
            .where(eq(epsPerSeasonTable.mediaId, mediaId))
            .orderBy(asc(epsPerSeasonTable.season))
            .execute();
    }
    async getMediaJobDetails(userId: number, job: JobType, name: string, offset: number, limit = 25) {
        const { mediaTable, listTable, actorTable, networkTable } = this.config;
        let dataQuery = getDbClient()
            .selectDistinct({
                mediaId: mediaTable.id,
                mediaName: mediaTable.name,
                imageCover: mediaTable.imageCover,
                inUserList: isNotNull(listTable.userId).mapWith(Boolean).as("inUserList"),
            })
            .from(mediaTable)
            .leftJoin(listTable, and(eq(listTable.mediaId, mediaTable.id), eq(listTable.userId, userId)))
            .$dynamic();
        let countQuery = getDbClient()
            .select({ value: countDistinct(mediaTable.id) })
            .from(mediaTable)
            .$dynamic();
        let filterCondition;
        if (job === JobType.ACTOR) {
            dataQuery = dataQuery.innerJoin(actorTable, eq(actorTable.mediaId, mediaTable.id));
            countQuery = countQuery.innerJoin(actorTable, eq(actorTable.mediaId, mediaTable.id));
            filterCondition = like(actorTable.name, `%${name}%`);
        }
        else if (job === JobType.CREATOR) {
            filterCondition = like(mediaTable.createdBy, `%${name}%`);
        }
        else if (job === JobType.PLATFORM) {
            dataQuery = dataQuery.innerJoin(networkTable, eq(networkTable.mediaId, mediaTable.id));
            countQuery = countQuery.innerJoin(networkTable, eq(networkTable.mediaId, mediaTable.id));
            filterCondition = like(networkTable.name, `%${name}%`);
        }
        else {
            throw notFound();
        }
        if (filterCondition) {
            dataQuery = dataQuery.where(filterCondition);
            countQuery = countQuery.where(filterCondition);
        }
        const [totalResult, results] = await Promise.all([
            countQuery.execute(),
            dataQuery.orderBy(asc(mediaTable.releaseDate)).limit(limit).offset(offset).execute(),
        ]);
        const totalCount = totalResult[0]?.value ?? 0;
        return {
            items: results,
            total: totalCount,
            pages: Math.ceil(totalCount / limit),
        };
    }
    async getMediaIdsToBeRefreshed(apiIds: number[]) {
        const { mediaTable } = this.config;
        const mediaIds = await getDbClient()
            .select({ apiId: mediaTable.apiId })
            .from(mediaTable)
            .where(and(
                inArray(mediaTable.apiId, apiIds),
                lte(mediaTable.lastApiUpdate, sql`datetime(CURRENT_TIMESTAMP, '-1 day')`),
            ));
        return mediaIds.map((m) => m.apiId);
    }
    async findAllAssociatedDetails(mediaId: number) {
        const { mediaTable, actorTable, genreTable, epsPerSeasonTable, networkTable } = this.config;
        const details = await getDbClient()
            .select({
                ...getTableColumns(mediaTable),
                actors: sql`json_group_array(DISTINCT json_object('id', ${actorTable.id}, 'name', ${actorTable.name}))`.mapWith(JSON.parse),
                genres: sql`json_group_array(DISTINCT json_object('id', ${genreTable.id}, 'name', ${genreTable.name}))`.mapWith(JSON.parse),
                epsPerSeason: sql`json_group_array(DISTINCT json_object('season', ${epsPerSeasonTable.season}, 'episodes', ${epsPerSeasonTable.episodes}))`.mapWith(JSON.parse),
                networks: sql`json_group_array(DISTINCT json_object('id', ${networkTable.id}, 'name', ${networkTable.name}))`.mapWith(JSON.parse),
            })
            .from(mediaTable)
            .innerJoin(actorTable, eq(actorTable.mediaId, mediaTable.id))
            .innerJoin(genreTable, eq(genreTable.mediaId, mediaTable.id))
            .innerJoin(epsPerSeasonTable, eq(epsPerSeasonTable.mediaId, mediaTable.id))
            .innerJoin(networkTable, eq(networkTable.mediaId, mediaTable.id))
            .where(eq(mediaTable.id, mediaId))
            .groupBy(...Object.values(getTableColumns(mediaTable)))
            .get();
        if (!details) return;
        const result: TvType & AddedMediaDetails = {
            ...details,
            genres: details.genres || [],
            actors: details.actors || [],
            networks: details.networks || [],
            epsPerSeason: details.epsPerSeason || [],
        };
        return result;
    }
    async storeMediaWithDetails({ mediaData, actorsData, seasonsData, networkData, genresData }: UpsertTvWithDetails) {
        const { mediaTable, actorTable, genreTable, epsPerSeasonTable, networkTable } = this.config;
        const result = await db.transaction(async (tx) => {
            const [media] = await tx
                .insert(mediaTable)
                .values(mediaData)
                .returning()
            if (!media) return;
            const mediaId = media.id;
            if (actorsData && actorsData.length > 0) {
                const actorsToAdd = actorsData.map((a) => ({ mediaId, name: a.name }));
                await tx.insert(actorTable).values(actorsToAdd)
            }
            if (genresData && genresData.length > 0) {
                const genresToAdd = genresData.map((g) => ({ mediaId, name: g.name }));
                await tx.insert(genreTable).values(genresToAdd)
            }
            if (seasonsData && seasonsData.length > 0) {
                const epsPerSeasonToAdd = seasonsData.map((data) => ({ mediaId, ...data }));
                await tx.insert(epsPerSeasonTable).values(epsPerSeasonToAdd)
            }
            if (networkData && networkData.length > 0) {
                const networkToAdd = networkData.map((n) => ({ mediaId, name: n.name }));
                await tx.insert(networkTable).values(networkToAdd)
            }
            return mediaId;
        });
        return result
    }
    async updateMediaWithDetails({ mediaData, actorsData, seasonsData, networkData, genresData }: UpsertTvWithDetails) {
        const { mediaTable, actorTable, genreTable, epsPerSeasonTable, networkTable } = this.config;
        const tx = getDbClient();
        const [media] = await tx
            .update(mediaTable)
            .set({ ...mediaData, lastApiUpdate: sql`CURRENT_TIMESTAMP` })
            .where(eq(mediaTable.apiId, mediaData.apiId))
            .returning({ id: mediaTable.id })
        const mediaId = media.id;
        if (actorsData && actorsData.length > 0) {
            await tx.delete(actorTable).where(eq(actorTable.mediaId, mediaId));
            const actorsToAdd = actorsData.map((a) => ({ mediaId, name: a.name }));
            await tx.insert(actorTable).values(actorsToAdd)
        }
        if (genresData && genresData.length > 0) {
            await tx.delete(genreTable).where(eq(genreTable.mediaId, mediaId));
            const genresToAdd = genresData.map((g) => ({ mediaId, name: g.name }));
            await tx.insert(genreTable).values(genresToAdd)
        }
        if (seasonsData && seasonsData.length > 0) {
            await tx.delete(epsPerSeasonTable).where(eq(epsPerSeasonTable.mediaId, mediaId));
            const epsPerSeasonToAdd = seasonsData.map((data) => ({ mediaId, ...data }));
            await tx.insert(epsPerSeasonTable).values(epsPerSeasonToAdd)
        }
        if (networkData && networkData.length > 0) {
            await tx.delete(networkTable).where(eq(networkTable.mediaId, mediaId));
            const networkToAdd = networkData.map((n) => ({ mediaId, name: n.name }));
            await tx.insert(networkTable).values(networkToAdd)
        }
        return true;
    }
    async getListFilters(userId: number) {
        const { mediaTable, listTable } = this.config;
        const { genres, labels } = await super.getCommonListFilters(userId);
        const langs = await getDbClient()
            .selectDistinct({ name: sql<string>`${mediaTable.originCountry}` })
            .from(mediaTable)
            .innerJoin(listTable, eq(listTable.mediaId, mediaTable.id))
            .where(and(eq(listTable.userId, userId), isNotNull(mediaTable.originCountry)));
        return { langs, genres, labels };
    }
    async getSearchListFilters(userId: number, query: string, job: JobType) {
        const { mediaTable, listTable, actorTable, networkTable } = this.config;
        if (job === JobType.ACTOR) {
            const actors = await getDbClient()
                .selectDistinct({ name: actorTable.name })
                .from(actorTable)
                .innerJoin(listTable, eq(listTable.mediaId, actorTable.mediaId))
                .where(and(eq(listTable.userId, userId), like(actorTable.name, `%${query}%`)));
            return actors
        }
        else if (job === JobType.CREATOR) {
            const creatorsQuery = await getDbClient()
                .selectDistinct({ name: mediaTable.createdBy })
                .from(mediaTable)
                .innerJoin(listTable, eq(listTable.mediaId, mediaTable.id))
                .where(and(eq(listTable.userId, userId), like(mediaTable.createdBy, `%${query}%`)));
            const creators = [...new Set(creatorsQuery
                .filter(c => c.name)
                .flatMap(c => c.name!.split(","))
                .filter(Boolean)
                .map(n => ({ name: n.trim() }))
            )];
            return creators
        }
        else if (job === JobType.PLATFORM) {
            const networks = await getDbClient()
                .selectDistinct({ name: networkTable.name })
                .from(networkTable)
                .innerJoin(listTable, eq(listTable.mediaId, networkTable.mediaId))
                .where(and(eq(listTable.userId, userId), like(networkTable.name, `%${query}%`)));
            return networks
        }
        else {
            throw new Error("Job type not supported");
        }
    }
    getDurationAchievementCte(achievement: Achievement, userId?: number) {
        const { mediaTable, listTable } = this.config;
        const value = parseInt(achievement.value!);
        const isLong = achievement.codeName.includes("long");
        const condition = isLong ? gte(mediaTable.totalEpisodes, value) : lte(mediaTable.totalEpisodes, value);
        let baseCTE = getDbClient()
            .select({
                userId: listTable.userId,
                value: count(listTable.mediaId).as("value"),
            }).from(listTable)
            .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id))
        const conditions = [eq(listTable.status, Status.COMPLETED), condition]
        return this.applyWhereConditionsAndGrouping(baseCTE, conditions, userId);
    }
    getNetworkAchievementCte(_achievement: Achievement, userId?: number) {
        const { listTable, networkTable } = this.config;
        let baseCTE = getDbClient()
            .select({
                userId: listTable.userId,
                value: countDistinct(networkTable.name).as("value"),
            }).from(listTable)
            .innerJoin(networkTable, eq(listTable.mediaId, networkTable.mediaId))
        const conditions = [ne(listTable.status, Status.PLAN_TO_WATCH)]
        return this.applyWhereConditionsAndGrouping(baseCTE, conditions, userId);
    }
    getActorAchievementCte(_achievement: Achievement, userId?: number) {
        const { listTable, actorTable } = this.config;
        let subQ = getDbClient()
            .select({
                userId: listTable.userId,
                count: count(listTable.mediaId).as("count"),
            }).from(listTable)
            .innerJoin(actorTable, eq(listTable.mediaId, actorTable.mediaId))
            .where(eq(listTable.status, Status.COMPLETED))
            .groupBy(userId ? eq(listTable.userId, userId) : listTable.userId, actorTable.name)
            .as("sub");
        return getDbClient()
            .select({
                userId: subQ.userId,
                value: max(subQ.count).as("value"),
            }).from(subQ)
            .groupBy(subQ.userId)
            .as("calculation");
    }
    async computeTotalSeasons(userId?: number) {
        const { listTable } = this.config;
        const forUser = userId ? eq(listTable.userId, userId) : undefined;
        const totalSeasons = await getDbClient()
            .select({ totalSeasons: sql<number>`coalesce(sum(${listTable.currentSeason}), 0)` })
            .from(listTable)
            .where(and(forUser, ne(listTable.status, Status.PLAN_TO_WATCH)))
            .get();
        return totalSeasons?.totalSeasons;
    }
    async avgTvDuration(userId?: number) {
        const { mediaTable, listTable } = this.config;
        const forUser = userId ? eq(listTable.userId, userId) : undefined;
        const avgDuration = await getDbClient()
            .select({
                average: sql<number | null>`avg(${mediaTable.duration} * ${listTable.total})`.as("avg_duration")
            })
            .from(mediaTable)
            .innerJoin(listTable, eq(listTable.mediaId, mediaTable.id))
            .where(and(forUser, notInArray(listTable.status, [Status.RANDOM, Status.PLAN_TO_WATCH])))
            .get();
        return avgDuration?.average;
    }
    async tvDurationDistrib(userId?: number) {
        const { mediaTable, listTable } = this.config;
        const forUser = userId ? eq(listTable.userId, userId) : undefined;
        return getDbClient()
            .select({
                name: sql<number>`floor((${mediaTable.duration} * ${listTable.total}) / 600.0) * 600`,
                value: count(mediaTable.id).as("count"),
            })
            .from(mediaTable)
            .innerJoin(listTable, eq(listTable.mediaId, mediaTable.id))
            .where(and(forUser, notInArray(listTable.status, [Status.RANDOM, Status.PLAN_TO_WATCH])))
            .groupBy(sql<number>`floor((${mediaTable.duration} * ${listTable.total}) / 600.0) * 600`)
            .orderBy(asc(sql<number>`floor((${mediaTable.duration} * ${listTable.total}) / 600.0) * 600`));
    }
    async specificTopMetrics(userId?: number) {
        const { mediaTable, listTable, networkTable, actorTable } = this.config;
        const networkConfig: ConfigTopMetric = {
            metricTable: networkTable,
            metricNameColumn: networkTable.name,
            metricIdColumn: mediaTable.id,
            mediaLinkColumn: listTable.mediaId,
            filters: [notInArray(listTable.status, [Status.RANDOM, Status.PLAN_TO_WATCH])],
        };
        const countriesConfig: ConfigTopMetric = {
            metricTable: mediaTable,
            metricNameColumn: mediaTable.originCountry,
            metricIdColumn: mediaTable.id,
            mediaLinkColumn: listTable.mediaId,
            filters: [notInArray(listTable.status, [Status.RANDOM, Status.PLAN_TO_WATCH])],
        };
        const actorsConfig: ConfigTopMetric = {
            metricTable: actorTable,
            metricNameColumn: actorTable.name,
            metricIdColumn: actorTable.mediaId,
            mediaLinkColumn: listTable.mediaId,
            filters: [notInArray(listTable.status, [Status.RANDOM, Status.PLAN_TO_WATCH])],
        };
        const actorsStats = await this.computeTopMetricStats(actorsConfig, userId);
        const networksStats = await this.computeTopMetricStats(networkConfig, userId);
        const countriesStats = await this.computeTopMetricStats(countriesConfig, userId);
        return { countriesStats, actorsStats, networksStats };
    }
}

================
File: src/lib/server/domain/media/tv/tv.service.ts
================
import {notFound} from "@tanstack/react-router";
import {MediaType, Status} from "@/lib/server/utils/enums";
import {ITvService} from "@/lib/server/types/services.types";
import {saveImageFromUrl} from "@/lib/server/utils/save-image";
import type {DeltaStats} from "@/lib/server/types/stats.types";
import {IProviderService} from "@/lib/server/types/provider.types";
import {ITvRepository} from "@/lib/server/types/repositories.types";
import {TvRepository} from "@/lib/server/domain/media/tv/tv.repository";
import {BaseService} from "@/lib/server/domain/media/base/base.service";
import {TvAdvancedStats, UserMediaWithLabels} from "@/lib/server/types/base.types";
import {Achievement, AchievementData} from "@/lib/server/types/achievements.types";
import {TvAchCodeName, TvList, TvType} from "@/lib/server/domain/media/tv/tv.types";
import {animeAchievements} from "@/lib/server/domain/media/tv/anime/achievements.seed";
import {seriesAchievements} from "@/lib/server/domain/media/tv/series/achievements.seed";
export class TvService extends BaseService<
    TvType, TvList, TvAdvancedStats, TvAchCodeName, ITvRepository
> implements ITvService {
    readonly achievementHandlers: Record<TvAchCodeName, (achievement: Achievement, userId?: number) => any>;
    constructor(repository: TvRepository) {
        super(repository);
        this.achievementHandlers = {
            completed_anime: this.repository.countCompletedAchievementCte.bind(this.repository),
            rated_anime: this.repository.countRatedAchievementCte.bind(this.repository),
            comment_anime: this.repository.countCommentedAchievementCte.bind(this.repository),
            short_anime: this.repository.getDurationAchievementCte.bind(this.repository),
            long_anime: this.repository.getDurationAchievementCte.bind(this.repository),
            shonen_anime: this.repository.specificGenreAchievementCte.bind(this.repository),
            seinen_anime: this.repository.specificGenreAchievementCte.bind(this.repository),
            network_anime: this.repository.getNetworkAchievementCte.bind(this.repository),
            actor_anime: this.repository.getActorAchievementCte.bind(this.repository),
            completed_series: this.repository.countCompletedAchievementCte.bind(this.repository),
            rated_series: this.repository.countRatedAchievementCte.bind(this.repository),
            short_series: this.repository.getDurationAchievementCte.bind(this.repository),
            long_series: this.repository.getDurationAchievementCte.bind(this.repository),
            comedy_series: this.repository.specificGenreAchievementCte.bind(this.repository),
            drama_series: this.repository.specificGenreAchievementCte.bind(this.repository),
            network_series: this.repository.getNetworkAchievementCte.bind(this.repository),
        };
    }
    async calculateAdvancedMediaStats(userId?: number) {
        const ratings = await this.repository.computeRatingStats(userId);
        const genresStats = await this.repository.computeTopGenresStats(userId);
        const totalLabels = await this.repository.computeTotalMediaLabel(userId);
        const releaseDates = await this.repository.computeReleaseDateStats(userId);
        const avgDuration = await this.repository.avgTvDuration(userId);
        const totalSeasons = await this.repository.computeTotalSeasons(userId);
        const durationDistrib = await this.repository.tvDurationDistrib(userId);
        const { networksStats, actorsStats, countriesStats } = await this.repository.specificTopMetrics(userId);
        return {
            ratings,
            totalLabels,
            genresStats,
            releaseDates,
            totalSeasons,
            avgDuration,
            durationDistrib,
            networksStats,
            actorsStats,
            countriesStats,
        } as TvAdvancedStats;
    }
    async getMediaAndUserDetails(userId: number, mediaId: number | string, external: boolean, providerService: IProviderService) {
        const media = external ?
            await this.repository.findByApiId(mediaId) : await this.repository.findById(mediaId as number);
        let internalMediaId = media?.id;
        if (external && !internalMediaId) {
            internalMediaId = await providerService.fetchAndStoreMediaDetails(mediaId as unknown as number);
            if (!internalMediaId) throw new Error("Failed to fetch media details");
        }
        if (internalMediaId) {
            const mediaWithDetails = await this.repository.findAllAssociatedDetails(internalMediaId);
            if (!mediaWithDetails) throw new Error("TV media not found");
            const userMedia = await this.repository.findUserMedia(userId, mediaWithDetails.id);
            if (userMedia) (userMedia as any).epsPerSeason = mediaWithDetails.epsPerSeason;
            const similarMedia = await this.repository.findSimilarMedia(mediaWithDetails.id)
            const followsData = await this.repository.getUserFollowsMediaData(userId, mediaWithDetails.id);
            return {
                media: mediaWithDetails,
                userMedia,
                followsData,
                similarMedia,
            };
        }
        throw new Error("TV media not found");
    }
    async getMediaEditableFields(mediaId: number) {
        const media = await this.repository.findById(mediaId);
        if (!media) throw notFound();
        const editableFields = this.repository.config.editableFields;
        const fields = editableFields.reduce((acc, field) => {
            if (field in media) {
                (acc as any)[field] = media[field];
            }
            return acc;
        }, {} as Pick<typeof media, typeof editableFields[number]>);
        return { fields };
    }
    async updateMediaEditableFields(mediaId: number, payload: Record<string, any>) {
        const media = await this.repository.findById(mediaId);
        if (!media) {
            throw notFound();
        }
        const editableFields = this.repository.config.editableFields;
        const fields: { [key: string]: any } = {};
        fields.apiId = media.apiId;
        if (payload?.imageCover) {
            const imageName = await saveImageFromUrl({
                defaultName: "default.jpg",
                imageUrl: payload.imageCover,
                resize: { width: 300, height: 450 },
                saveLocation: "public/static/covers/movies-covers",
            });
            fields.imageCover = imageName;
            delete payload.imageCover;
        }
        for (const key in payload) {
            if (Object.prototype.hasOwnProperty.call(payload, key) && editableFields.includes(key)) {
                fields[key] = payload[key];
            }
        }
        await this.repository.updateMediaWithDetails({ mediaData: fields });
    }
    async getComingNext(userId: number) {
        return this.repository.getComingNext(userId);
    }
    async addMediaToUserList(userId: number, mediaId: number, status?: Status) {
        const newStatus = status ?? this.repository.config.mediaList.defaultStatus;
        const media = await this.repository.findByIdAndAddEpsPerSeason(mediaId);
        if (!media) throw notFound();
        const userMedia = await this.repository.findUserMedia(userId, mediaId);
        if (userMedia) throw new Error("Media already in your list");
        const newState = await this.repository.addMediaToUserList(userId, media, newStatus);
        const delta = this.calculateDeltaStats(null, newState, media);
        return { newState, media, delta };
    }
    async updateUserMediaDetails(userId: number, mediaId: number, partialUpdateData: Record<string, any>) {
        const media = await this.repository.findByIdAndAddEpsPerSeason(mediaId);
        if (!media) throw notFound();
        const oldState = await this.repository.findUserMedia(userId, mediaId);
        if (!oldState) throw new Error("Media not in your list");
        const mediaEpsPerSeason = await this.repository.getMediaEpsPerSeason(mediaId);
        (media as any).epsPerSeason = mediaEpsPerSeason;
        (oldState as any).epsPerSeason = mediaEpsPerSeason;
        const completeUpdateData = this.completePartialUpdateData(partialUpdateData, oldState);
        const newState = await this.repository.updateUserMediaDetails(userId, mediaId, completeUpdateData);
        const delta = this.calculateDeltaStats(oldState, newState, media);
        return { os: oldState, ns: newState, media, delta, updateData: completeUpdateData };
    }
    async removeMediaFromUserList(userId: number, mediaId: number) {
        const media = await this.repository.findByIdAndAddEpsPerSeason(mediaId);
        if (!media) throw notFound();
        const oldState = await this.repository.findUserMedia(userId, mediaId);
        if (!oldState) throw new Error("Media not in your list");
        await this.repository.removeMediaFromUserList(userId, mediaId);
        const delta = this.calculateDeltaStats(oldState, null, media);
        return delta;
    }
    completePartialUpdateData(partialUpdateData: Record<string, any>, userMedia: TvList) {
        let completeUpdateData = { ...partialUpdateData };
        if (completeUpdateData.status) {
            if (userMedia.lastEpisodeWatched === 0 && ![Status.PLAN_TO_WATCH, Status.RANDOM].includes(completeUpdateData.status)) {
                completeUpdateData = { ...completeUpdateData, lastEpisodeWatched: 1 };
            }
            if ([Status.PLAN_TO_WATCH, Status.RANDOM].includes(completeUpdateData.status)) {
                completeUpdateData = {
                    ...completeUpdateData,
                    currentSeason: 1,
                    lastEpisodeWatched: 1,
                    redo2: Array(userMedia.epsPerSeason!.length).fill(0)
                };
            }
            if (completeUpdateData.status === Status.COMPLETED) {
                completeUpdateData = {
                    ...completeUpdateData,
                    currentSeason: userMedia.epsPerSeason![-1].season,
                    lastEpisodeWatched: userMedia.epsPerSeason![-1].episodes,
                };
            }
        }
        return completeUpdateData;
    }
    calculateDeltaStats(oldState: UserMediaWithLabels<TvList> | null, newState: TvList | null, media: TvType) {
        const delta: DeltaStats = {};
        const statusCounts: Partial<Record<Status, number>> = {};
        const oldStatus = oldState?.status;
        const oldRating = oldState?.rating;
        const oldComment = oldState?.comment;
        const oldRedo = oldState?.redo2 ?? [];
        const oldFavorite = oldState?.favorite ?? false;
        const oldTotalSpecificValue = oldState?.total ?? 0;
        const oldTotalTimeSpent = oldTotalSpecificValue * media.duration;
        const oldSumRedo = oldState?.redo2.reduce((a, c) => a + c, 0) ?? 0;
        const wasCompleted = oldStatus === Status.COMPLETED;
        const wasFavorited = wasCompleted && oldFavorite;
        const wasCommented = wasCompleted && !!oldComment;
        const wasRated = wasCompleted && oldRating != null;
        const newRedo = newState?.redo2;
        const newStatus = newState?.status;
        const newRating = newState?.rating;
        const newComment = newState?.comment;
        const newFavorite = newState?.favorite ?? false;
        const newSumRedo = newState?.redo2.reduce((a, c) => a + c, 0) ?? 0;
        const isCompleted = newStatus === Status.COMPLETED;
        const isFavorited = isCompleted && newFavorite;
        const isCommented = isCompleted && !!newComment;
        const isRated = isCompleted && newRating != null;
        const redoDiff = newRedo?.map((val, idx) => val - oldRedo[idx]);
        const valuesToApply = redoDiff?.reduce((sum, diff, i) => sum + diff * media.epsPerSeason![i].episodes, 0);
        const newTotalSpecificValue = oldTotalSpecificValue + (valuesToApply ?? 0);
        const newTotalTimeSpent = newTotalSpecificValue * media.duration;
        if (!oldState && newState) {
            delta.totalEntries = 1;
        }
        else if (oldState && !newState) {
            delta.totalEntries = -1;
        }
        if (oldStatus !== newStatus) {
            if (oldStatus) {
                statusCounts[oldStatus] = (statusCounts[oldStatus] ?? 0) - 1;
            }
            if (newStatus) {
                statusCounts[newStatus] = (statusCounts[newStatus] ?? 0) + 1;
            }
        }
        delta.timeSpent = (newTotalTimeSpent - oldTotalTimeSpent);
        delta.totalRedo = (newSumRedo - oldSumRedo);
        delta.totalSpecific = (newTotalSpecificValue - oldTotalSpecificValue);
        let entriesRatedDelta = 0;
        let sumEntriesRatedDelta = 0;
        if (wasRated && !isRated) {
            entriesRatedDelta = -1;
            sumEntriesRatedDelta = -(oldRating ?? 0);
        }
        else if (!wasRated && isRated) {
            entriesRatedDelta = 1;
            sumEntriesRatedDelta = newRating ?? 0;
        }
        else if (wasRated && isRated && oldRating !== newRating) {
            sumEntriesRatedDelta = (newRating ?? 0) - (oldRating ?? 0);
        }
        delta.entriesRated = entriesRatedDelta;
        delta.sumEntriesRated = sumEntriesRatedDelta;
        let entriesCommentedDelta = 0;
        if (wasCommented && !isCommented) {
            entriesCommentedDelta = -1;
        }
        else if (!wasCommented && isCommented) {
            entriesCommentedDelta = 1;
        }
        delta.entriesCommented = entriesCommentedDelta;
        let entriesFavoritesDelta = 0;
        if (wasFavorited && !isFavorited) {
            entriesFavoritesDelta = -1;
        }
        else if (!wasFavorited && isFavorited) {
            entriesFavoritesDelta = 1;
        }
        delta.entriesFavorites = entriesFavoritesDelta;
        if (Object.keys(statusCounts).length > 0) {
            delta.statusCounts = statusCounts;
        }
        return delta;
    }
    getAchievementsDefinition(mediaType?: MediaType) {
        if (mediaType === MediaType.ANIME) {
            return animeAchievements as unknown as AchievementData[];
        }
        else if (mediaType === MediaType.SERIES) {
            return seriesAchievements as unknown as AchievementData[];
        }
        else {
            return [] as AchievementData[];
        }
    }
}

================
File: src/lib/server/types/media-lists.types.ts
================
import {Column, SQL, Table} from "drizzle-orm";
import {Status} from "@/lib/server/utils/enums";
import {SQLiteColumn} from "drizzle-orm/sqlite-core";
import {FilterDefinitions} from "@/lib/server/types/base.types";
export interface RelatedEntityConfig<TJoinTable extends Table, TEntityTable extends Table> {
    entityTable: TEntityTable;
    idColumnInMedia: TJoinTable[keyof TJoinTable];
    filterColumnInEntity: TEntityTable[keyof TEntityTable];
    mediaIdColumnInEntity: TEntityTable[keyof TEntityTable];
}
interface MediaTableColumns {
    id: Column<any, any, any>;
    name: Column<any, any, any>;
    apiId: Column<any, any, any>;
    synopsis: Column<any, any, any>;
    imageCover: Column<any, any, any>;
    releaseDate: Column<any, any, any>;
    lastApiUpdate: Column<any, any, any>;
}
interface ListTableColumns {
    id: Column<any, any, any>;
    userId: Column<any, any, any>;
    mediaId: Column<any, any, any>;
    status: Column<any, any, any>;
    favorite: Column<any, any, any>;
    comment: Column<any, any, any>;
    rating: Column<any, any, any>;
}
interface LabelTableColumns {
    id: Column<any, any, any>;
    userId: Column<any, any, any>;
    mediaId: Column<any, any, any>;
    name: Column<any, any, any>;
}
interface GenreTableColumns {
    id: Column<any, any, any>;
    name: Column<any, any, any>;
    mediaId: Column<any, any, any>;
}
export type ListTable = Table & ListTableColumns;
export type MediaTable = Table & MediaTableColumns;
export type LabelTable = Table & LabelTableColumns;
export type GenreTable = Table & GenreTableColumns;
export type TableWithMediaId = Table & { mediaId: Column<any, any, any> };
type BaseSelection<TListTable, TMediaTable> = {
    [K in keyof TListTable]: SQLiteColumn
} | {
    [K in keyof TMediaTable]: SQLiteColumn
} | {
    mediaName: SQLiteColumn
}
export interface MediaSchemaConfig<
    TMediaTable extends MediaTable,
    TListTable extends ListTable,
    TGenreTable extends GenreTable,
    TLabelTable extends LabelTable
> {
    mediaTable: TMediaTable;
    listTable: TListTable;
    genreTable: TGenreTable;
    labelTable: TLabelTable;
    mediaList: {
        defaultStatus: Status;
        defaultSortName: string;
        filterDefinitions: FilterDefinitions;
        availableSorts: Record<string, SQL | SQL[]>;
        baseSelection: BaseSelection<TListTable, TMediaTable> & { epsPerSeason?: SQL };
    }
    apiProvider: {
        maxGenres: number;
    }
    editableFields: Array<keyof TMediaTable["$inferSelect"]>;
    tablesForDeletion: TableWithMediaId[];
}
export type TActorTableParam = Table;
export type TNetworkTableParam = Table;
export type TEpsPerSeasonTableParam = Table;
export interface TVSchemaConfig<
    TMediaTable extends MediaTable,
    TListTable extends ListTable,
    TGenreTable extends GenreTable,
    TLabelTable extends LabelTable,
    TActorTableParam extends Table,
    TNetworkTableParam extends Table,
    TEpsPerSeasonTableParam extends Table,
> extends MediaSchemaConfig<TMediaTable, TListTable, TGenreTable, TLabelTable> {
    actorTable: TActorTableParam;
    networkTable: TNetworkTableParam;
    epsPerSeasonTable: TEpsPerSeasonTableParam;
}

================
File: src/lib/server/types/base.types.ts
================
import {Column, SQL} from "drizzle-orm";
import {Label} from "@/lib/components/types";
import {DeltaStats} from "@/lib/server/types/stats.types";
import {MediaTable} from "@/lib/server/types/media-lists.types";
import {SQLiteColumn, SQLiteTable} from "drizzle-orm/sqlite-core";
import {authOptions} from "@/lib/react-query/query-options/query-options";
import {GamesPlatformsEnum, MediaType, NotificationType, RatingSystemType, Status} from "@/lib/server/utils/enums";
export interface MediaListArgs {
    page?: number;
    perPage?: number;
    search?: string;
    sort?: string,
    status?: Status[];
    genres?: string[];
    labels?: string[];
    langs?: string[];
    favorite?: boolean;
    comment?: boolean;
    hideCommon?: boolean;
    sorting?: string;
    directors?: string[];
    platforms?: GamesPlatformsEnum[];
    publishers?: string[];
    actors?: string[];
    authors?: string[];
    companies?: string[];
    networks?: string[];
    creators?: string[];
    currentUserId?: number;
    userId?: number;
}
export type ComingNext = {
    mediaId: number,
    mediaName: string,
    imageCover: string,
    date: string | null,
    seasonToAir?: number | null,
    episodeToAir?: number | null,
}
export type UserMediaStats = {
    userId: number;
    timeSpent: number;
    totalRedo: number;
    totalEntries: number;
    entriesRated: number;
    totalSpecific: number;
    averageRating: number;
    sumEntriesRated: number;
    entriesFavorites: number;
    entriesCommented: number;
    statusCounts: Record<string, number>;
};
export type ItemForNotification = {
    userId: number;
    mediaId: number;
    mediaName: string;
    releaseDate: string | null;
    lastEpisode?: number | null;
    seasonToAir?: number | null;
    episodeToAir?: number | null;
};
export type UpdateMediaNotification = {
    userId: number,
    mediaId: number,
    mediaType: MediaType,
    payload: NotificationPayload,
    notificationType: NotificationType,
};
export type NotificationPayload = {
    name: string;
    final?: boolean;
    season?: number | null;
    episode?: number | null;
    releaseDate: string | null;
};
export type JobDetails = {
    items: JobDetail[];
    total: number;
    pages: number;
};
export type JobDetail = {
    mediaId: number,
    mediaName: string,
    imageCover: string,
    inUserList: boolean,
};
export type AddedMediaDetails = {
    genres: { id: number, name: string }[];
    actors?: { id: number, name: string }[];
    networks?: { id: number, name: string }[];
    platforms?: { id: number, name: string }[];
    epsPerSeason?: { season: number, episodes: number }[];
    collection?: { mediaId: number, mediaName: string, mediaCover: string }[];
    companies?: { id: number, name: string, developer: boolean, publisher: boolean }[];
};
export type CommonListFilters = {
    genres: { name: string }[];
    labels: { name: string }[];
};
export type ExpandedListFilters = CommonListFilters & {
    langs?: { name: string }[];
    platforms?: { name: GamesPlatformsEnum }[];
};
export type TopMetricStats = {
    topValues: { name: string, value: number }[];
    topRated: { name: string, value: number }[];
    topFavorited: { name: string, value: number }[];
};
export type UserMediaWithLabels<TList> = TList & {
    labels: { name: string }[],
    ratingSystem: RatingSystemType,
};
export type UserFollowsMediaData<TList> = {
    id: number;
    name: string;
    image: string;
    userMedia: TList;
    ratingSystem: RatingSystemType;
}
export type MediaListData<TList> = {
    items: (TList & {
        common: boolean;
        mediaName: string;
        imageCover: string;
        ratingSystem: RatingSystemType;
    })[];
    pagination: {
        page: number;
        perPage: number;
        sorting: string;
        totalPages: number;
        totalItems: number;
        availableSorting: string[];
    };
}
export type EditUserLabels = {
    label: Label;
    userId: number;
    mediaId: number;
    action: "add" | "rename" | "deleteOne" | "deleteAll";
}
export type ConfigTopMetric = {
    limit?: number,
    minRatingCount?: number,
    filters: SQL[],
    metricTable: SQLiteTable,
    metricIdColumn: SQLiteColumn,
    mediaLinkColumn: SQLiteColumn,
    metricNameColumn: SQLiteColumn,
}
export type AdvancedMediaStats = {
    totalLabels: number,
    ratings: NameValuePair[],
    genresStats: TopMetricStats,
    releaseDates: NameValuePair[],
    durationDistrib: NameValuePair[];
    avgDuration: number | null | undefined;
}
export type MoviesAdvancedStats = AdvancedMediaStats & {
    langsStats: TopMetricStats;
    actorsStats: TopMetricStats;
    directorsStats: TopMetricStats;
    totalBudget: number | undefined,
    totalRevenue: number | null | undefined;
}
export type TvAdvancedStats = AdvancedMediaStats & {
    actorsStats: TopMetricStats;
    networksStats: TopMetricStats;
    countriesStats: TopMetricStats;
    totalSeasons: number | null | undefined;
}
export type GamesAdvancedStats = AdvancedMediaStats & {
    enginesStats: TopMetricStats;
    platformsStats: TopMetricStats;
    developersStats: TopMetricStats;
    publishersStats: TopMetricStats;
    perspectivesStats: TopMetricStats;
    gameModes: { topValues: { name: string, value: number }[] };
}
export type SimpleMedia = {
    mediaId: number,
    mediaName: string,
    mediaCover: string,
}
export type MediaAndUserDetails<TMedia, TList> = {
    similarMedia: SimpleMedia[];
    media: TMedia & AddedMediaDetails;
    followsData: UserFollowsMediaData<TList>[];
    userMedia: UserMediaWithLabels<TList> | null;
}
export type AddMediaToUserList<TMedia, TList> = {
    newState: TList;
    delta: DeltaStats;
    media: TMedia;
}
export type UpdateUserMediaDetails<TMedia, TList> = {
    os: UserMediaWithLabels<TList>;
    ns: TList;
    media: TMedia;
    delta: DeltaStats;
    updateData: Record<string, any>;
}
export type ListFilterDefinition = {
    mediaTable: MediaTable;
    entityTable: SQLiteTable & { mediaId: Column<any, any, any> };
    filterColumn: SQLiteColumn;
    argName: keyof MediaListArgs;
}
export type FilterDefinition = {
    isActive: (args: MediaListArgs) => boolean;
    getCondition: (args: MediaListArgs) => SQL | undefined;
}
export type FilterDefinitions = Partial<Record<keyof MediaListArgs, FilterDefinition>>;
export type CurrentUser = ReturnType<typeof authOptions>["queryFn"];
export type EpsPerSeasonType = { season: number, episodes: number }[];
type NameValuePair = { name: string | number, value: number };
export type HofSorting = "normalized" | "profile" | MediaType;
export type SearchTypeHoF = SearchType & Omit<SearchType, "sorting"> & { sorting?: HofSorting };
export type SearchType = {
    page?: number;
    search?: string;
    sorting?: string;
    perPage?: number;
}

================
File: src/lib/server/domain/media/movies/movies.service.ts
================
import {Status} from "@/lib/server/utils/enums";
import {notFound} from "@tanstack/react-router";
import {saveImageFromUrl} from "@/lib/server/utils/save-image";
import type {DeltaStats} from "@/lib/server/types/stats.types";
import {IMoviesService} from "@/lib/server/types/services.types";
import {IProviderService} from "@/lib/server/types/provider.types";
import {IMoviesRepository} from "@/lib/server/types/repositories.types";
import {BaseService} from "@/lib/server/domain/media/base/base.service";
import {Achievement, AchievementData} from "@/lib/server/types/achievements.types";
import {MoviesRepository} from "@/lib/server/domain/media/movies/movies.repository";
import {moviesAchievements} from "@/lib/server/domain/media/movies/achievements.seed";
import {MoviesAdvancedStats, UserMediaWithLabels} from "@/lib/server/types/base.types";
import {Movie, MoviesAchCodeName, MoviesList} from "@/lib/server/domain/media/movies/movies.types";
export class MoviesService extends BaseService<
    Movie, MoviesList, MoviesAdvancedStats, MoviesAchCodeName, IMoviesRepository
> implements IMoviesService {
    readonly achievementHandlers: Record<MoviesAchCodeName, (achievement: Achievement, userId?: number) => any>;
    constructor(repository: MoviesRepository) {
        super(repository);
        this.achievementHandlers = {
            completed_movies: this.repository.countCompletedAchievementCte.bind(this.repository),
            rated_movies: this.repository.countRatedAchievementCte.bind(this.repository),
            comment_movies: this.repository.countCommentedAchievementCte.bind(this.repository),
            director_movies: this.repository.getDirectorAchievementCte.bind(this.repository),
            actor_movies: this.repository.getActorAchievementCte.bind(this.repository),
            origin_lang_movies: this.repository.getLanguageAchievementCte.bind(this.repository),
            war_genre_movies: this.repository.specificGenreAchievementCte.bind(this.repository),
            family_genre_movies: this.repository.specificGenreAchievementCte.bind(this.repository),
            sci_genre_movies: this.repository.specificGenreAchievementCte.bind(this.repository),
            animation_movies: this.repository.specificGenreAchievementCte.bind(this.repository),
            long_movies: this.repository.getDurationAchievementCte.bind(this.repository),
            short_movies: this.repository.getDurationAchievementCte.bind(this.repository),
        };
    }
    async lockOldMovies() {
        return this.repository.lockOldMovies();
    }
    async calculateAdvancedMediaStats(userId?: number) {
        const ratings = await this.repository.computeRatingStats(userId);
        const genresStats = await this.repository.computeTopGenresStats(userId);
        const totalLabels = await this.repository.computeTotalMediaLabel(userId);
        const releaseDates = await this.repository.computeReleaseDateStats(userId);
        const avgDuration = await this.repository.avgMovieDuration(userId);
        const durationDistrib = await this.repository.movieDurationDistrib(userId);
        const { totalBudget, totalRevenue } = await this.repository.budgetRevenueStats(userId);
        const { directorsStats, actorsStats, langsStats } = await this.repository.specificTopMetrics(userId);
        return {
            ratings,
            totalLabels,
            genresStats,
            releaseDates,
            totalBudget,
            totalRevenue,
            avgDuration,
            durationDistrib,
            directorsStats,
            actorsStats,
            langsStats,
        } as MoviesAdvancedStats;
    }
    async getMediaAndUserDetails(userId: number, mediaId: number | string, external: boolean, providerService: IProviderService) {
        const media = external ?
            await this.repository.findByApiId(mediaId) : await this.repository.findById(mediaId as number);
        let internalMediaId = media?.id;
        if (external && !internalMediaId) {
            internalMediaId = await providerService.fetchAndStoreMediaDetails(mediaId as unknown as number);
            if (!internalMediaId) throw new Error("Failed to fetch the details");
        }
        if (internalMediaId) {
            const mediaWithDetails = await this.repository.findAllAssociatedDetails(internalMediaId);
            if (!mediaWithDetails) throw new Error("Movie not found");
            const similarMedia = await this.repository.findSimilarMedia(mediaWithDetails.id);
            const userMedia = await this.repository.findUserMedia(userId, mediaWithDetails.id);
            const followsData = await this.repository.getUserFollowsMediaData(userId, mediaWithDetails.id);
            return {
                media: mediaWithDetails,
                userMedia,
                followsData,
                similarMedia,
            };
        }
        throw new Error("Movie not found")
    }
    async getMediaEditableFields(mediaId: number) {
        const media = await this.repository.findById(mediaId);
        if (!media) throw notFound();
        const editableFields = this.repository.config.editableFields;
        const fields = {} as Record<string, any>;
        for (const key in media) {
            if (Object.prototype.hasOwnProperty.call(media, key) && editableFields.includes(key as keyof Movie)) {
                fields[key as keyof typeof media] = media[key as keyof typeof media];
            }
        }
        return { fields };
    }
    async updateMediaEditableFields(mediaId: number, payload: Record<string, any>) {
        const media = await this.repository.findById(mediaId);
        if (!media) throw notFound();
        const editableFields = this.repository.config.editableFields;
        const fields = {} as Record<Partial<keyof Movie>, any>;
        fields.apiId = media.apiId;
        if (payload?.imageCover) {
            const imageName = await saveImageFromUrl({
                defaultName: "default.jpg",
                imageUrl: payload.imageCover,
                resize: { width: 300, height: 450 },
                saveLocation: "public/static/covers/movies-covers",
            });
            fields.imageCover = imageName;
            delete payload.imageCover;
        }
        for (const key in payload) {
            if (Object.prototype.hasOwnProperty.call(payload, key) && editableFields.includes(key as keyof Movie)) {
                fields[key as keyof typeof media] = payload[key as keyof typeof media];
            }
        }
        await this.repository.updateMediaWithDetails({ mediaData: fields });
    }
    async getComingNext(userId: number) {
        return this.repository.getComingNext(userId);
    }
    async addMediaToUserList(userId: number, mediaId: number, status?: Status) {
        const newStatus = status ?? this.repository.config.mediaList.defaultStatus;
        const media = await this.repository.findById(mediaId);
        if (!media) throw notFound();
        const userMedia = await this.repository.findUserMedia(userId, mediaId);
        if (userMedia) throw new Error("Media already in your list");
        const newState = await this.repository.addMediaToUserList(userId, media, newStatus);
        const delta = this.calculateDeltaStats(null, newState, media);
        return { newState, media, delta };
    }
    async updateUserMediaDetails(userId: number, mediaId: number, partialUpdateData: Record<string, any>) {
        const media = await this.repository.findById(mediaId);
        if (!media) throw notFound();
        const oldState = await this.repository.findUserMedia(userId, mediaId);
        if (!oldState) throw new Error("Media not in your list");
        const completeUpdateData = this.completePartialUpdateData(partialUpdateData);
        const newState = await this.repository.updateUserMediaDetails(userId, mediaId, completeUpdateData);
        const delta = this.calculateDeltaStats(oldState, newState, media);
        return {
            os: oldState,
            ns: newState,
            media,
            delta,
            updateData: completeUpdateData,
        };
    }
    async removeMediaFromUserList(userId: number, mediaId: number) {
        const media = await this.repository.findById(mediaId);
        if (!media) throw notFound();
        const oldState = await this.repository.findUserMedia(userId, mediaId);
        if (!oldState) throw new Error("Media not in your list");
        await this.repository.removeMediaFromUserList(userId, mediaId);
        const delta = this.calculateDeltaStats(oldState, null, media);
        return delta;
    }
    completePartialUpdateData(partialUpdateData: Record<string, any>, _userMedia?: MoviesList) {
        const completeUpdateData = { ...partialUpdateData };
        if (completeUpdateData.status) {
            return { ...completeUpdateData, redo: 0 };
        }
        return completeUpdateData;
    }
    calculateDeltaStats(oldState: UserMediaWithLabels<MoviesList> | null, newState: MoviesList | null, media: Movie) {
        const delta: DeltaStats = {};
        const statusCounts: Partial<Record<Status, number>> = {};
        const oldStatus = oldState?.status;
        const oldRating = oldState?.rating;
        const oldRedo = oldState?.redo ?? 0;
        const oldComment = oldState?.comment;
        const oldFavorite = oldState?.favorite ?? false;
        const oldTotalSpecificValue = oldState?.total ?? 0;
        const oldTotalTimeSpent = oldTotalSpecificValue * media.duration;
        const wasCompleted = oldStatus === Status.COMPLETED;
        const wasFavorited = wasCompleted && oldFavorite;
        const wasCommented = wasCompleted && !!oldComment;
        const wasRated = wasCompleted && oldRating != null;
        const newStatus = newState?.status;
        const newRating = newState?.rating;
        const newRedo = newState?.redo ?? 0;
        const newComment = newState?.comment;
        const newFavorite = newState?.favorite ?? false;
        const isCompleted = newStatus === Status.COMPLETED;
        const isFavorited = isCompleted && newFavorite;
        const isCommented = isCompleted && !!newComment;
        const isRated = isCompleted && newRating != null;
        const newTotalSpecificValue = newState ? (isCompleted ? 1 : 0) + newRedo : 0;
        const newTotalTimeSpent = newTotalSpecificValue * media.duration;
        if (!oldState && newState) {
            delta.totalEntries = 1;
        }
        else if (oldState && !newState) {
            delta.totalEntries = -1;
        }
        if (oldStatus !== newStatus) {
            if (oldStatus) {
                statusCounts[oldStatus] = (statusCounts[oldStatus] ?? 0) - 1;
            }
            if (newStatus) {
                statusCounts[newStatus] = (statusCounts[newStatus] ?? 0) + 1;
            }
        }
        delta.timeSpent = (newTotalTimeSpent - oldTotalTimeSpent);
        delta.totalRedo = (newRedo - oldRedo);
        delta.totalSpecific = (newTotalSpecificValue - oldTotalSpecificValue);
        let entriesRatedDelta = 0;
        let sumEntriesRatedDelta = 0;
        if (wasRated && !isRated) {
            entriesRatedDelta = -1;
            sumEntriesRatedDelta = -(oldRating ?? 0);
        }
        else if (!wasRated && isRated) {
            entriesRatedDelta = 1;
            sumEntriesRatedDelta = newRating ?? 0;
        }
        else if (wasRated && isRated && oldRating !== newRating) {
            sumEntriesRatedDelta = (newRating ?? 0) - (oldRating ?? 0);
        }
        delta.entriesRated = entriesRatedDelta;
        delta.sumEntriesRated = sumEntriesRatedDelta;
        let entriesCommentedDelta = 0;
        if (wasCommented && !isCommented) {
            entriesCommentedDelta = -1;
        }
        else if (!wasCommented && isCommented) {
            entriesCommentedDelta = 1;
        }
        delta.entriesCommented = entriesCommentedDelta;
        let entriesFavoritesDelta = 0;
        if (wasFavorited && !isFavorited) {
            entriesFavoritesDelta = -1;
        }
        else if (!wasFavorited && isFavorited) {
            entriesFavoritesDelta = 1;
        }
        delta.entriesFavorites = entriesFavoritesDelta;
        if (Object.keys(statusCounts).length > 0) {
            delta.statusCounts = statusCounts;
        }
        return delta;
    }
    getAchievementsDefinition() {
        return moviesAchievements as unknown as AchievementData[];
    }
}

================
File: src/lib/server/domain/media/movies/movies.repository.ts
================
import {db} from "@/lib/server/database/db";
import {JobType, Status} from "@/lib/server/utils/enums";
import {getDbClient} from "@/lib/server/database/async-storage";
import {Achievement} from "@/lib/server/types/achievements.types";
import {IMoviesRepository} from "@/lib/server/types/repositories.types";
import {BaseRepository} from "@/lib/server/domain/media/base/base.repository";
import {AddedMediaDetails, ConfigTopMetric} from "@/lib/server/types/base.types";
import {movies, moviesActors, moviesGenre, moviesList} from "@/lib/server/database/schema";
import {MovieSchemaConfig, moviesConfig} from "@/lib/server/domain/media/movies/movies.config";
import {Movie, MoviesList, UpsertMovieWithDetails} from "@/lib/server/domain/media/movies/movies.types";
import {and, asc, count, countDistinct, eq, getTableColumns, gte, isNotNull, like, lte, max, ne, or, sql} from "drizzle-orm";
export class MoviesRepository extends BaseRepository<Movie, MoviesList, MovieSchemaConfig> implements IMoviesRepository {
    config: MovieSchemaConfig;
    constructor() {
        super(moviesConfig);
        this.config = moviesConfig;
    }
    async getComingNext(userId: number) {
        const comingNext = await getDbClient()
            .select({
                mediaId: movies.id,
                mediaName: movies.name,
                date: movies.releaseDate,
                imageCover: movies.imageCover,
            })
            .from(movies)
            .innerJoin(moviesList, eq(moviesList.mediaId, movies.id))
            .where(and(eq(moviesList.userId, userId), gte(movies.releaseDate, sql`CURRENT_TIMESTAMP`)))
            .orderBy(asc(movies.releaseDate))
            .execute();
        return comingNext;
    }
    async lockOldMovies() {
        const [{ count }] = await getDbClient()
            .select({ count: sql<number>`count(*)` })
            .from(movies)
            .where(and(eq(movies.lockStatus, false), lte(movies.releaseDate, sql`datetime('now', '-6 months')`)))
            .execute();
        await getDbClient()
            .update(movies)
            .set({ lockStatus: true })
            .where(and(eq(movies.lockStatus, false), lte(movies.releaseDate, sql`datetime('now', '-6 months')`)))
            .execute();
        return count;
    }
    async computeAllUsersStats() {
        const results = await getDbClient()
            .select({
                userId: moviesList.userId,
                timeSpent: sql<number>`
                    COALESCE(SUM(
                        CASE
                            WHEN ${moviesList.status} = ${Status.COMPLETED} THEN (1 + ${moviesList.redo}) * ${movies.duration}
                            ELSE 0
                        END
                    ), 0)
                `.as("timeSpent"),
                totalSpecific: sql<number>`
                    COALESCE(SUM(
                        CASE
                            WHEN ${moviesList.status} = ${Status.COMPLETED} THEN 1 + ${moviesList.redo}
                            ELSE 0
                        END
                    ), 0)
                `.as("totalSpecific"),
                statusCounts: sql`
                    COALESCE((
                        SELECT
                            JSON_GROUP_OBJECT(status, count_per_status)
                        FROM (
                            SELECT
                                status,
                                COUNT(*) as count_per_status
                            FROM ${moviesList} as sub_list
                            WHERE sub_list.user_id = ${moviesList.userId} GROUP BY status
                        )
                    ), '{}')
                `.as("statusCounts"),
                entriesFavorites: sql<number>`
                    COALESCE(SUM(CASE WHEN ${moviesList.favorite} = 1 THEN 1 ELSE 0 END), 0)
                `.as("entriesFavorites"),
                totalRedo: sql<number>`COALESCE(SUM(${moviesList.redo}), 0)`.as("totalRedo"),
                entriesCommented: sql<number>`
                    COALESCE(SUM(CASE WHEN LENGTH(TRIM(COALESCE(${moviesList.comment}, ''))) > 0 THEN 1 ELSE 0 END), 0)
                `.as("entriesCommented"),
                totalEntries: count(moviesList.mediaId).as("totalEntries"),
                entriesRated: count(moviesList.rating).as("entriesRated"),
                sumEntriesRated: sql<number>`COALESCE(SUM(${moviesList.rating}), 0)`.as("sumEntriesRated"),
                averageRating: sql<number>`
                    COALESCE(SUM(${moviesList.rating}) * 1.0 / NULLIF(COUNT(${moviesList.rating}), 0), 0.0)
                `.as("averageRating"),
            })
            .from(moviesList)
            .innerJoin(movies, eq(moviesList.mediaId, movies.id))
            .groupBy(moviesList.userId)
            .execute();
        return results.map((row) => {
            let statusCounts: Record<string, number> = {};
            try {
                const parsed = typeof row.statusCounts === "string" ? JSON.parse(row.statusCounts) : row.statusCounts;
                if (typeof parsed === "object" && parsed !== null) {
                    statusCounts = parsed;
                }
            }
            catch (e) {
                console.error(`Failed to parse statusCounts for user ${row.userId}:`, row.statusCounts, e);
            }
            return {
                userId: row.userId,
                statusCounts: statusCounts,
                timeSpent: Number(row.timeSpent) || 0,
                totalRedo: Number(row.totalRedo) || 0,
                totalEntries: Number(row.totalEntries) || 0,
                entriesRated: Number(row.entriesRated) || 0,
                totalSpecific: Number(row.totalSpecific) || 0,
                averageRating: Number(row.averageRating) || 0,
                sumEntriesRated: Number(row.sumEntriesRated) || 0,
                entriesFavorites: Number(row.entriesFavorites) || 0,
                entriesCommented: Number(row.entriesCommented) || 0,
            };
        });
    }
    async getMediaToNotify() {
        return getDbClient()
            .select({
                mediaId: movies.id,
                mediaName: movies.name,
                releaseDate: movies.releaseDate,
                userId: moviesList.userId,
            })
            .from(movies)
            .innerJoin(moviesList, eq(moviesList.mediaId, movies.id))
            .where(and(
                isNotNull(movies.releaseDate),
                gte(movies.releaseDate, sql`datetime('now')`),
                lte(movies.releaseDate, sql`datetime('now', '+7 days')`),
            ))
            .orderBy(movies.releaseDate)
            .execute();
    }
    async addMediaToUserList(userId: number, media: Movie, newStatus: Status) {
        const newTotal = (newStatus === Status.COMPLETED) ? 1 : 0;
        const [newMedia] = await getDbClient()
            .insert(moviesList)
            .values({ userId, mediaId: media.id, total: newTotal, status: newStatus })
            .returning();
        return newMedia;
    }
    async getMediaJobDetails(userId: number, job: JobType, name: string, offset: number, limit = 25) {
        let dataQuery = getDbClient()
            .selectDistinct({
                mediaId: movies.id,
                mediaName: movies.name,
                imageCover: movies.imageCover,
                inUserList: isNotNull(moviesList.userId).mapWith(Boolean).as("inUserList"),
            })
            .from(movies)
            .leftJoin(moviesList, and(eq(moviesList.mediaId, movies.id), eq(moviesList.userId, userId)))
            .$dynamic();
        let countQuery = getDbClient()
            .select({ value: countDistinct(movies.id) })
            .from(movies)
            .$dynamic();
        let filterCondition;
        if (job === JobType.ACTOR) {
            dataQuery = dataQuery.innerJoin(moviesActors, eq(moviesActors.mediaId, movies.id));
            countQuery = countQuery.innerJoin(moviesActors, eq(moviesActors.mediaId, movies.id));
            filterCondition = like(moviesActors.name, `%${name}%`);
        }
        else if (job === JobType.CREATOR) {
            filterCondition = like(movies.directorName, `%${name}%`);
        }
        else if (job === JobType.COMPOSITOR) {
            filterCondition = like(movies.compositorName, `%${name}%`);
        }
        else {
            throw new Error("Job type not supported");
        }
        if (filterCondition) {
            dataQuery = dataQuery.where(filterCondition);
            countQuery = countQuery.where(filterCondition);
        }
        const [totalResult, results] = await Promise.all([
            countQuery.execute(),
            dataQuery.orderBy(asc(movies.releaseDate)).limit(limit).offset(offset).execute(),
        ]);
        const totalCount = totalResult[0]?.value ?? 0;
        return {
            items: results,
            total: totalCount,
            pages: Math.ceil(totalCount / limit),
        };
    }
    async getMediaIdsToBeRefreshed() {
        const results = await getDbClient()
            .select({ apiId: movies.apiId })
            .from(movies)
            .where(and(
                lte(movies.lastApiUpdate, sql`datetime(CURRENT_TIMESTAMP, '-2 days')`),
                or(
                    gte(movies.releaseDate, sql`CURRENT_TIMESTAMP`),
                    gte(movies.releaseDate, sql`datetime(CURRENT_TIMESTAMP, '-6 months')`),
                )));
        return results.map((r) => r.apiId);
    }
    async findAllAssociatedDetails(mediaId: number) {
        const details = await getDbClient()
            .select({
                ...getTableColumns(movies),
                actors: sql`json_group_array(DISTINCT json_object('id', ${moviesActors.id}, 'name', ${moviesActors.name}))`.mapWith(JSON.parse),
                genres: sql`json_group_array(DISTINCT json_object('id', ${moviesGenre.id}, 'name', ${moviesGenre.name}))`.mapWith(JSON.parse),
                collection: sql`
                    CASE
                        WHEN ${movies.collectionId} IS NULL
                        THEN json_array()
                        ELSE (
                            SELECT COALESCE(json_group_array(json_object(
                                'mediaId', m2.id,
                                'mediaName', m2.name,
                                'mediaCover', m2.image_cover
                            )), json_array())
                            FROM movies m2
                            WHERE m2.collection_id = ${movies.collectionId}
                            AND m2.id != ${movies.id}
                        )
                    END
                `.mapWith(JSON.parse),
            }).from(movies)
            .innerJoin(moviesActors, eq(moviesActors.mediaId, movies.id))
            .innerJoin(moviesGenre, eq(moviesGenre.mediaId, movies.id))
            .where(eq(movies.id, mediaId))
            .groupBy(...Object.values(getTableColumns(movies)))
            .get();
        if (!details) return;
        const result: Movie & AddedMediaDetails = {
            ...details,
            actors: details.actors || [],
            genres: details.genres || [],
            collection: details.collection || [],
        };
        return result;
    }
    async storeMediaWithDetails({ mediaData, actorsData, genresData }: UpsertMovieWithDetails) {
        const result = await db.transaction(async (tx) => {
            const [media] = await tx
                .insert(movies)
                .values(mediaData)
                .returning()
            if (!media) return;
            const mediaId = media.id;
            if (actorsData && actorsData.length > 0) {
                const actorsToAdd = actorsData.map((a) => ({ mediaId, name: a.name }));
                await tx.insert(moviesActors).values(actorsToAdd)
            }
            if (genresData && genresData.length > 0) {
                const genresToAdd = genresData.map((g) => ({ mediaId, name: g.name }));
                await tx.insert(moviesGenre).values(genresToAdd)
            }
            return mediaId;
        });
        return result;
    }
    async updateMediaWithDetails({ mediaData, actorsData, genresData }: UpsertMovieWithDetails) {
        const tx = getDbClient();
        const [media] = await tx
            .update(movies)
            .set({ ...mediaData, lastApiUpdate: sql`CURRENT_TIMESTAMP` })
            .where(eq(movies.apiId, mediaData.apiId))
            .returning({ id: movies.id })
        const mediaId = media.id;
        if (actorsData && actorsData.length > 0) {
            await tx.delete(moviesActors).where(eq(moviesActors.mediaId, mediaId));
            const actorsToAdd = actorsData.map((a) => ({ mediaId, name: a.name }));
            await tx.insert(moviesActors).values(actorsToAdd)
        }
        if (genresData && genresData.length > 0) {
            await tx.delete(moviesGenre).where(eq(moviesGenre.mediaId, mediaId));
            const genresToAdd = genresData.map((g) => ({ mediaId, name: g.name }));
            await tx.insert(moviesGenre).values(genresToAdd)
        }
        return true;
    }
    async getListFilters(userId: number) {
        const { genres, labels } = await super.getCommonListFilters(userId);
        const langs = await getDbClient()
            .selectDistinct({ name: sql<string>`${movies.originalLanguage}` })
            .from(movies)
            .innerJoin(moviesList, eq(moviesList.mediaId, movies.id))
            .where(and(eq(moviesList.userId, userId), isNotNull(movies.originalLanguage)));
        return { langs, genres, labels };
    }
    async getSearchListFilters(userId: number, query: string, job: JobType) {
        if (job === JobType.ACTOR) {
            const actors = await db
                .selectDistinct({ name: moviesActors.name })
                .from(moviesActors)
                .innerJoin(moviesList, eq(moviesList.mediaId, moviesActors.mediaId))
                .where(and(eq(moviesList.userId, userId), like(moviesActors.name, `%${query}%`)));
            return actors
        }
        else if (job === JobType.CREATOR) {
            const directors = await db
                .selectDistinct({ name: movies.directorName })
                .from(movies)
                .innerJoin(moviesList, eq(moviesList.mediaId, movies.id))
                .where(and(eq(moviesList.userId, userId), like(movies.directorName, `%${query}%`)));
            return directors
        }
        else if (job === JobType.COMPOSITOR) {
            const compositors = await db
                .selectDistinct({ name: movies.compositorName })
                .from(movies)
                .innerJoin(moviesList, eq(moviesList.mediaId, movies.id))
                .where(and(eq(moviesList.userId, userId), like(movies.compositorName, `%${query}%`)));
            return compositors
        }
        else {
            throw new Error("Job type not supported");
        }
    }
    getDurationAchievementCte(achievement: Achievement, userId?: number) {
        const value = parseInt(achievement.value!);
        const isLong = achievement.codeName.includes("long");
        const condition = isLong ? gte(movies.duration, value) : lte(movies.duration, value);
        let baseCTE = getDbClient()
            .select({
                userId: moviesList.userId,
                value: count(moviesList.mediaId).as("value"),
            }).from(moviesList)
            .innerJoin(movies, eq(moviesList.mediaId, movies.id))
        const conditions = [eq(moviesList.status, Status.COMPLETED), condition]
        return this.applyWhereConditionsAndGrouping(baseCTE, conditions, userId);
    }
    getDirectorAchievementCte(_achievement: Achievement, userId?: number) {
        let subQ = getDbClient()
            .select({
                userId: moviesList.userId,
                count: count(moviesList.mediaId).as("count"),
            }).from(moviesList)
            .innerJoin(movies, eq(moviesList.mediaId, movies.id))
            .where(eq(moviesList.status, Status.COMPLETED))
            .groupBy(userId ? eq(moviesList.userId, userId) : moviesList.userId, movies.directorName)
            .as("sub");
        return getDbClient()
            .select({
                userId: subQ.userId,
                value: max(subQ.count).as("value"),
            }).from(subQ)
            .groupBy(subQ.userId)
            .as("calculation");
    }
    getActorAchievementCte(_achievement: Achievement, userId?: number) {
        let subQ = getDbClient()
            .select({
                userId: moviesList.userId,
                count: count(moviesList.mediaId).as("count"),
            }).from(moviesList)
            .innerJoin(moviesActors, eq(moviesList.mediaId, moviesActors.mediaId))
            .where(eq(moviesList.status, Status.COMPLETED))
            .groupBy(userId ? eq(moviesList.userId, userId) : moviesList.userId, moviesActors.name)
            .as("sub");
        return getDbClient()
            .select({
                userId: subQ.userId,
                value: max(subQ.count).as("value"),
            }).from(subQ)
            .groupBy(subQ.userId)
            .as("calculation");
    }
    getLanguageAchievementCte(_achievement: Achievement, userId?: number) {
        let baseCTE = getDbClient()
            .select({
                userId: moviesList.userId,
                value: countDistinct(movies.originalLanguage).as("value"),
            }).from(moviesList)
            .innerJoin(movies, eq(moviesList.mediaId, movies.id))
        const conditions = [eq(moviesList.status, Status.COMPLETED)]
        return this.applyWhereConditionsAndGrouping(baseCTE, conditions, userId);
    }
    async avgMovieDuration(userId?: number) {
        const forUser = userId ? eq(moviesList.userId, userId) : undefined;
        const avgDuration = await getDbClient()
            .select({
                average: sql<number | null>`avg(${movies.duration})`
            })
            .from(movies)
            .innerJoin(moviesList, eq(moviesList.mediaId, movies.id))
            .where(and(forUser, ne(moviesList.status, Status.PLAN_TO_WATCH), isNotNull(movies.duration)))
            .get();
        return avgDuration?.average;
    }
    async movieDurationDistrib(userId?: number) {
        const forUser = userId ? eq(moviesList.userId, userId) : undefined;
        return getDbClient()
            .select({
                name: sql<number>`floor(${movies.duration} / 30.0) * 30`,
                value: sql<number>`cast(count(${movies.id}) as int)`.as("count"),
            })
            .from(movies)
            .innerJoin(moviesList, eq(moviesList.mediaId, movies.id))
            .where(and(forUser, ne(moviesList.status, Status.PLAN_TO_WATCH), isNotNull(movies.duration)))
            .groupBy(sql<number>`floor(${movies.duration} / 30.0) * 30`)
            .orderBy(asc(sql<number>`floor(${movies.duration} / 30.0) * 30`));
    }
    async budgetRevenueStats(userId?: number) {
        const forUser = userId ? eq(moviesList.userId, userId) : undefined;
        const data = await getDbClient()
            .select({
                totalBudget: sql<number>`coalesce(sum(${movies.budget}), 0)`.as("total_budget"),
                totalRevenue: sql<number>`coalesce(sum(${movies.revenue}), 0)`.as("total_revenue"),
            })
            .from(movies)
            .innerJoin(moviesList, eq(moviesList.mediaId, movies.id))
            .where(and(forUser, ne(moviesList.status, Status.PLAN_TO_WATCH)))
            .get();
        return { totalBudget: data?.totalBudget, totalRevenue: data?.totalRevenue };
    }
    async specificTopMetrics(userId?: number) {
        const langsConfig: ConfigTopMetric = {
            metricTable: movies,
            metricNameColumn: movies.originalLanguage,
            metricIdColumn: movies.id,
            mediaLinkColumn: moviesList.mediaId,
            filters: [ne(moviesList.status, Status.PLAN_TO_WATCH)],
        };
        const directorsConfig: ConfigTopMetric = {
            metricTable: movies,
            metricNameColumn: movies.directorName,
            metricIdColumn: movies.id,
            mediaLinkColumn: moviesList.mediaId,
            filters: [ne(moviesList.status, Status.PLAN_TO_WATCH)],
        };
        const actorsConfig: ConfigTopMetric = {
            metricTable: moviesActors,
            metricNameColumn: moviesActors.name,
            metricIdColumn: moviesActors.mediaId,
            mediaLinkColumn: moviesList.mediaId,
            filters: [ne(moviesList.status, Status.PLAN_TO_WATCH)],
        };
        const langsStats = await this.computeTopMetricStats(langsConfig, userId);
        const actorsStats = await this.computeTopMetricStats(actorsConfig, userId);
        const directorsStats = await this.computeTopMetricStats(directorsConfig, userId);
        return { directorsStats, actorsStats, langsStats };
    }
}

================
File: src/lib/server/domain/media/base/base.repository.ts
================
import {Label} from "@/lib/components/types";
import {Status} from "@/lib/server/utils/enums";
import {followers, user} from "@/lib/server/database/schema";
import {getDbClient} from "@/lib/server/database/async-storage";
import {Achievement} from "@/lib/server/types/achievements.types";
import {IUniversalRepository} from "@/lib/server/types/repositories.types";
import {GenreTable, LabelTable, ListTable, MediaSchemaConfig, MediaTable} from "@/lib/server/types/media-lists.types";
import {and, asc, count, desc, eq, getTableColumns, gte, inArray, isNotNull, isNull, like, ne, notInArray, SQL, sql} from "drizzle-orm";
import {
    ConfigTopMetric,
    EditUserLabels,
    FilterDefinition,
    FilterDefinitions,
    ListFilterDefinition,
    MediaListArgs,
    MediaListData,
    UserFollowsMediaData,
    UserMediaWithLabels
} from "@/lib/server/types/base.types";
const ALL_VALUE = "All";
const DEFAULT_PER_PAGE = 25;
const SIMILAR_MAX_GENRES = 12;
export class BaseRepository<
    TMedia, TList,
    TConfig extends MediaSchemaConfig<MediaTable, ListTable, GenreTable, LabelTable>
> implements IUniversalRepository<TMedia, TList> {
    protected readonly config: TConfig;
    protected readonly baseFilterDefs: FilterDefinitions;
    constructor(config: TConfig) {
        this.config = config;
        this.baseFilterDefs = this.baseListFiltersDefs();
    }
    private baseListFiltersDefs = () => {
        const { listTable, mediaTable, genreTable } = this.config;
        return {
            search: {
                isActive: (args: MediaListArgs) => !!args.search,
                getCondition: (args: MediaListArgs) => like(mediaTable.name, `%${args.search}%`),
            },
            status: {
                isActive: (args: MediaListArgs) => isValidFilter(args.status),
                getCondition: (args: MediaListArgs) => inArray(listTable.status, args.status!.filter((s: any) => s !== ALL_VALUE)),
            },
            favorite: {
                isActive: (args: MediaListArgs) => args.favorite === true,
                getCondition: (_args: MediaListArgs) => eq(listTable.favorite, true),
            },
            comment: {
                isActive: (args: MediaListArgs) => args.comment === true,
                getCondition: (_args: MediaListArgs) => isNotNull(listTable.comment),
            },
            hideCommon: {
                isActive: (args: MediaListArgs) => args.hideCommon === true && args.currentUserId && args.currentUserId !== args.userId,
                getCondition: (args: MediaListArgs) => {
                    const subQuery = getDbClient()
                        .select({ mediaId: listTable.mediaId })
                        .from(listTable)
                        .where(eq(listTable.userId, args.currentUserId!));
                    return notInArray(listTable.mediaId, subQuery);
                },
            },
            genres: createListFilterDef({
                argName: "genres",
                mediaTable: mediaTable,
                entityTable: genreTable,
                filterColumn: genreTable.name,
            }),
        } as FilterDefinitions;
    }
    async findById(mediaId: number) {
        const { mediaTable } = this.config;
        const result = await getDbClient()
            .select()
            .from(mediaTable)
            .where(eq(mediaTable.id, mediaId))
            .get();
        return result as TMedia | undefined;
    }
    async findByApiId(apiId: number | string) {
        const { mediaTable } = this.config;
        const result = await getDbClient()
            .select()
            .from(mediaTable)
            .where(eq(mediaTable.apiId, apiId))
            .get()
        return result as TMedia | undefined;
    }
    async updateUserMediaDetails(userId: number, mediaId: number, updateData: Partial<TList>) {
        const { listTable } = this.config;
        const [result] = await getDbClient()
            .update(listTable)
            .set(updateData)
            .where(and(eq(listTable.userId, userId), eq(listTable.mediaId, mediaId)))
            .returning();
        return result as TList;
    }
    async downloadMediaListAsCSV(userId: number) {
        const { mediaTable, listTable } = this.config;
        const data = await getDbClient()
            .select({
                ...getTableColumns(listTable),
                mediaName: sql<string>`${mediaTable.name}`,
            })
            .from(listTable)
            .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id))
            .where(eq(listTable.userId, userId));
        return data as (TMedia & { mediaName: string })[] | undefined;
    }
    async searchByName(query: string, limit: number = 20) {
        const { mediaTable } = this.config;
        return getDbClient()
            .select({ name: sql<string>`${mediaTable.name}` })
            .from(mediaTable)
            .where(like(mediaTable.name, `%${query}%`))
            .orderBy(mediaTable.name)
            .limit(limit)
            .execute();
    }
    async removeMediaByIds(mediaIds: number[]) {
        const { tablesForDeletion } = this.config;
        for (const table of tablesForDeletion) {
            await getDbClient()
                .delete(table)
                .where(inArray(table.mediaId, mediaIds))
                .execute();
        }
    }
    async getNonListMediaIds() {
        const { mediaTable, listTable } = this.config;
        const mediaToDelete = await getDbClient()
            .select({ id: sql<number>`${mediaTable.id}` })
            .from(mediaTable)
            .leftJoin(listTable, eq(listTable.mediaId, mediaTable.id))
            .where(isNull(listTable.userId))
            .execute();
        return mediaToDelete.map((media) => media.id);
    }
    async getCoverFilenames() {
        const { mediaTable } = this.config;
        return getDbClient()
            .select({ imageCover: mediaTable.imageCover })
            .from(mediaTable)
            .execute()
    }
    async findSimilarMedia(mediaId: number) {
        const { mediaTable, genreTable } = this.config;
        const targetGenresSubQuery = getDbClient()
            .select({ name: genreTable.name })
            .from(genreTable)
            .where(eq(genreTable.mediaId, mediaId));
        const similarSub = getDbClient()
            .select({
                movieId: genreTable.mediaId,
                commonGenreCount: count(genreTable.name).as("common_genre_count")
            })
            .from(genreTable)
            .where(and(ne(genreTable.mediaId, mediaId), inArray(genreTable.name, targetGenresSubQuery)))
            .groupBy(genreTable.mediaId)
            .orderBy(desc(sql`common_genre_count`))
            .limit(SIMILAR_MAX_GENRES)
            .as("similar_media");
        return getDbClient()
            .select({
                mediaId: sql<number>`${mediaTable.id}`,
                mediaName: sql<string>`${mediaTable.name}`,
                mediaCover: mediaTable.imageCover,
            })
            .from(similarSub)
            .innerJoin(mediaTable, eq(mediaTable.id, similarSub.movieId))
            .orderBy(desc(similarSub.commonGenreCount));
    }
    async getUserMediaLabels(userId: number) {
        const { labelTable } = this.config;
        return getDbClient()
            .selectDistinct({ name: sql<string>`${labelTable.name}` })
            .from(labelTable)
            .where(eq(labelTable.userId, userId))
            .orderBy(asc(labelTable.name));
    }
    async editUserLabel({ userId, label, mediaId, action }: EditUserLabels) {
        const { labelTable } = this.config;
        if (action === "add") {
            const [labelData] = await getDbClient()
                .insert(labelTable)
                .values({ userId, name: label.name, mediaId })
                .returning({ name: labelTable.name })
            return labelData as Label;
        }
        else if (action === "rename") {
            const [labelData] = await getDbClient()
                .update(labelTable)
                .set({ name: label.name })
                .where(and(eq(labelTable.userId, userId), eq(labelTable.name, label?.oldName)))
                .returning({ name: labelTable.name })
            return labelData as Label;
        }
        else if (action === "deleteOne") {
            await getDbClient()
                .delete(labelTable)
                .where(and(eq(labelTable.userId, userId), eq(labelTable.name, label.name), eq(labelTable.mediaId, mediaId)))
                .execute();
        }
        else if (action === "deleteAll") {
            await getDbClient()
                .delete(labelTable)
                .where(and(eq(labelTable.userId, userId), eq(labelTable.name, label.name)))
                .execute();
        }
    }
    async removeMediaFromUserList(userId: number, mediaId: number) {
        const { listTable, labelTable } = this.config;
        await getDbClient()
            .delete(listTable)
            .where(and(eq(listTable.userId, userId), eq(listTable.mediaId, mediaId)))
            .execute();
        await getDbClient()
            .delete(labelTable)
            .where(and(eq(labelTable.userId, userId), eq(labelTable.mediaId, mediaId)))
            .execute();
    }
    async getUserFavorites(userId: number, limit = 8) {
        const { listTable, mediaTable } = this.config;
        return getDbClient()
            .select({
                mediaId: sql<number>`${mediaTable.id}`,
                mediaName: sql<string>`${mediaTable.name}`,
                mediaCover: mediaTable.imageCover,
            })
            .from(listTable)
            .where(and(eq(listTable.userId, userId), eq(listTable.favorite, true)))
            .leftJoin(mediaTable, eq(listTable.mediaId, mediaTable.id))
            .limit(limit)
    }
    async findUserMedia(userId: number, mediaId: number) {
        const { listTable, labelTable } = this.config;
        const mainUserMediaData = await getDbClient()
            .select({
                ...getTableColumns(listTable),
                ratingSystem: user.ratingSystem,
            })
            .from(listTable)
            .innerJoin(user, eq(user.id, listTable.userId))
            .where(and(eq(listTable.userId, userId), eq(listTable.mediaId, mediaId)))
            .get()
        if (!mainUserMediaData) {
            return null;
        }
        const associatedLabels = await getDbClient()
            .select({ name: sql<string>`${labelTable.name}` })
            .from(labelTable)
            .where(and(eq(labelTable.mediaId, mediaId), eq(labelTable.userId, userId)))
            .orderBy(asc(labelTable.name))
            .execute();
        if (!associatedLabels) {
            return null;
        }
        return { ...mainUserMediaData, labels: associatedLabels } as UserMediaWithLabels<TList>;
    }
    async getUserFollowsMediaData(userId: number, mediaId: number) {
        const { listTable } = this.config;
        const inFollowsLists = await getDbClient()
            .select({
                id: user.id,
                name: user.name,
                image: user.image,
                userMedia: listTable,
                ratingSystem: user.ratingSystem,
            })
            .from(followers)
            .innerJoin(user, eq(user.id, followers.followedId))
            .innerJoin(listTable, eq(listTable.userId, followers.followedId))
            .where(and(eq(followers.followerId, userId), eq(listTable.mediaId, mediaId)));
        return inFollowsLists as UserFollowsMediaData<TList>[];
    }
    async getCommonListFilters(userId: number) {
        const { genreTable, labelTable, listTable } = this.config;
        const genresPromise = getDbClient()
            .selectDistinct({ name: sql<string>`${genreTable.name}` })
            .from(genreTable)
            .innerJoin(listTable, eq(listTable.mediaId, genreTable.mediaId))
            .where(eq(listTable.userId, userId))
            .orderBy(asc(genreTable.name));
        const labelsPromise = getDbClient()
            .selectDistinct({ name: sql<string>`${labelTable.name}` })
            .from(labelTable)
            .where(and(eq(labelTable.userId, userId)))
            .orderBy(asc(labelTable.name));
        const [genres, labels] = await Promise.all([genresPromise, labelsPromise]);
        return { genres, labels };
    }
    async getMediaList(currentUserId: number | undefined, userId: number, args: MediaListArgs) {
        const { listTable, mediaTable, mediaList } = this.config;
        const page = args.page ?? 1;
        const perPage = args.perPage ?? DEFAULT_PER_PAGE;
        const offset = (page - 1) * perPage;
        const sortKeyName = args.sort ? args.sort : mediaList.defaultSortName;
        const selectedSort = mediaList.availableSorts[sortKeyName];
        const filterArgs = { ...args, currentUserId, userId };
        const allFilters = {
            ...this.baseFilterDefs,
            ...mediaList.filterDefinitions,
        };
        let queryBuilder = getDbClient()
            .select({
                ...mediaList.baseSelection,
                ratingSystem: user.ratingSystem,
            })
            .from(listTable)
            .innerJoin(user, eq(listTable.userId, user.id))
            .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id))
            .$dynamic();
        let countQueryBuilder = getDbClient()
            .select({ count: count() })
            .from(listTable)
            .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id))
            .$dynamic();
        const conditions = [];
        conditions.push(eq(listTable.userId, userId));
        for (const key of Object.keys(allFilters)) {
            const filterDef = allFilters[key as keyof MediaListArgs];
            if (filterDef?.isActive(filterArgs)) {
                const condition = filterDef.getCondition(filterArgs);
                if (condition) {
                    conditions.push(condition);
                }
            }
        }
        queryBuilder = queryBuilder.where(and(...conditions));
        countQueryBuilder = countQueryBuilder.where(and(...conditions));
        const finalQuery = queryBuilder
            .orderBy(...(Array.isArray(selectedSort) ? selectedSort : [selectedSort]))
            .limit(perPage)
            .offset(offset);
        const [results, totalResult] = await Promise.all([finalQuery.execute(), countQueryBuilder.get()]);
        const totalItems = totalResult?.count ?? 0;
        const totalPages = Math.ceil(totalItems / perPage);
        let commonIdsSet = new Set<number>();
        if (currentUserId && currentUserId !== userId && !filterArgs.hideCommon && results.length > 0) {
            const mediaIds = results.map((m: any) => m.mediaId);
            const commonMediaIdsResult = await getDbClient()
                .select({ mediaId: listTable.mediaId })
                .from(listTable)
                .where(and(eq(listTable.userId, currentUserId), inArray(listTable.mediaId, mediaIds)))
                .execute();
            commonIdsSet = new Set(commonMediaIdsResult.map(m => m.mediaId));
        }
        const processedResults = results.map((item: any) => ({
            ...item,
            common: commonIdsSet.has(item.mediaId),
        }));
        return {
            items: processedResults,
            pagination: {
                page,
                perPage,
                totalPages,
                totalItems,
                sorting: sortKeyName,
                availableSorting: Object.keys(mediaList.availableSorts),
            },
        } as MediaListData<TList>;
    }
    applyWhereConditionsAndGrouping(cte: any, baseConditions: SQL[], userId?: number) {
        const { listTable } = this.config;
        const conditions = userId ? [...baseConditions] : [...baseConditions, eq(listTable.userId, userId)];
        return cte.where(and(...conditions))
            .groupBy(listTable.userId)
            .as("calculation");
    }
    countCompletedAchievementCte(_achievement: Achievement, userId?: number) {
        const { listTable } = this.config;
        let baseCTE = getDbClient()
            .select({
                userId: listTable.userId,
                value: count(listTable.mediaId).as("value"),
            }).from(listTable);
        const conditions = [eq(listTable.status, Status.COMPLETED)]
        return this.applyWhereConditionsAndGrouping(baseCTE, conditions, userId);
    }
    countRatedAchievementCte(_achievement: Achievement, userId?: number) {
        const { listTable } = this.config;
        let baseCTE = getDbClient()
            .select({
                userId: listTable.userId,
                value: count(listTable.mediaId).as("value"),
            }).from(listTable);
        const conditions = [isNotNull(listTable.rating)]
        return this.applyWhereConditionsAndGrouping(baseCTE, conditions, userId);
    }
    countCommentedAchievementCte(_achievement: Achievement, userId?: number) {
        const { listTable } = this.config;
        let baseCTE = getDbClient()
            .select({
                userId: listTable.userId,
                value: count(listTable.mediaId).as("value"),
            }).from(listTable);
        const conditions = [isNotNull(listTable.comment)]
        return this.applyWhereConditionsAndGrouping(baseCTE, conditions, userId);
    }
    specificGenreAchievementCte(achievement: Achievement, userId?: number) {
        const { mediaTable, listTable, genreTable } = this.config;
        const baseCTE = getDbClient()
            .select({
                userId: listTable.userId,
                value: count(listTable.mediaId).as("value"),
            })
            .from(listTable)
            .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id))
            .innerJoin(genreTable, eq(mediaTable.id, genreTable.mediaId));
        const conditions = [eq(listTable.status, Status.COMPLETED), eq(genreTable.name, achievement.value)];
        return this.applyWhereConditionsAndGrouping(baseCTE, conditions, userId);
    }
    async computeRatingStats(userId?: number) {
        const { listTable } = this.config;
        const forUser = userId ? eq(listTable.userId, userId) : undefined;
        const ratingDistrib: { [key: string]: number } = {};
        for (let i = 0; i <= 20; i++) {
            ratingDistrib[(i * 0.5).toFixed(1)] = 0;
        }
        const ratingQuery = await getDbClient()
            .select({
                rating: listTable.rating,
                count: count(listTable.rating),
            })
            .from(listTable)
            .where(and(forUser, isNotNull(listTable.rating)))
            .groupBy(listTable.rating)
            .orderBy(asc(listTable.rating))
            .execute();
        ratingQuery.forEach((result) => {
            const ratingKey = result?.rating?.toFixed(1);
            if (ratingKey) {
                ratingDistrib[ratingKey] = result.count;
            }
        });
        const ratings = Object.entries(ratingDistrib).map(([name, value]) => ({ name, value }));
        return ratings.sort((a, b) => parseFloat(a.name) - parseFloat(b.name));
    }
    async computeReleaseDateStats(userId?: number) {
        const { mediaTable, listTable } = this.config;
        const forUser = userId ? eq(listTable.userId, userId) : undefined;
        const releaseDates = await getDbClient()
            .select({
                name: sql<number>`floor(extract(year from ${mediaTable.releaseDate}) / 10.0) * 10`,
                value: sql<number>`cast(count(${mediaTable.releaseDate}) as int)`.as("count"),
            })
            .from(mediaTable)
            .innerJoin(listTable, eq(listTable.mediaId, mediaTable.id))
            .where(and(forUser, isNotNull(mediaTable.releaseDate)))
            .groupBy(sql<number>`floor(extract(year from ${mediaTable.releaseDate}) / 10.0) * 10`)
            .orderBy(asc(sql<number>`floor(extract(year from ${mediaTable.releaseDate}) / 10.0) * 10`))
            .execute();
        return releaseDates;
    }
    async computeTotalMediaLabel(userId?: number) {
        const { labelTable } = this.config;
        const forUser = userId ? eq(labelTable.userId, userId) : undefined;
        const result = await getDbClient()
            .selectDistinct({ count: count(labelTable.name) })
            .from(labelTable)
            .where(and(forUser))
            .get();
        return result?.count ?? 0;
    }
    async computeTopGenresStats(userId?: number) {
        const { genreTable, listTable } = this.config;
        const metricStatsConfig = {
            metricTable: genreTable,
            metricNameColumn: genreTable.name,
            metricIdColumn: genreTable.mediaId,
            mediaLinkColumn: listTable.mediaId,
            filters: [notInArray(listTable.status, [Status.PLAN_TO_WATCH, Status.PLAN_TO_PLAY, Status.PLAN_TO_READ])],
        };
        return this.computeTopMetricStats(metricStatsConfig, userId);
    }
    async computeTopMetricStats(statsConfig: ConfigTopMetric, userId?: number) {
        const { mediaTable, listTable } = this.config;
        const forUser = userId ? eq(listTable.userId, userId) : undefined;
        const limit = statsConfig?.limit ?? 10;
        const minRatingCount = statsConfig?.minRatingCount ?? 5;
        const { metricTable, metricIdColumn, metricNameColumn, mediaLinkColumn, filters } = statsConfig;
        const countAlias = sql<number>`countDistinct(${metricNameColumn})`
        const topValuesQuery = getDbClient()
            .select({
                name: sql<string>`${metricNameColumn}`,
                value: countAlias,
            })
            .from(listTable)
            .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id))
            .innerJoin(metricTable, eq(mediaLinkColumn, metricIdColumn))
            .where(and(forUser, isNotNull(metricNameColumn), ...filters))
            .groupBy(metricNameColumn)
            .orderBy(asc(countAlias))
            .limit(limit)
        const avgRatingAlias = sql<number>`avgDistinct(${metricNameColumn})`;
        const ratingCountAlias = sql<number>`count(${listTable.rating})`;
        const topRatedQuery = getDbClient()
            .select({
                name: sql<string>`${metricNameColumn}`,
                value: avgRatingAlias,
            })
            .from(listTable)
            .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id))
            .innerJoin(metricTable, eq(mediaLinkColumn, metricIdColumn))
            .where(and(forUser, isNotNull(metricNameColumn), isNotNull(listTable.rating), ...filters))
            .groupBy(metricNameColumn)
            .having(gte(ratingCountAlias, minRatingCount))
            .orderBy(asc(avgRatingAlias))
            .limit(limit);
        const topFavoritedQuery = getDbClient()
            .select({
                name: sql<string>`${metricNameColumn}`,
                value: countAlias,
            })
            .from(listTable)
            .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id))
            .innerJoin(metricTable, eq(mediaLinkColumn, metricIdColumn))
            .where(and(forUser, isNotNull(metricNameColumn), eq(listTable.favorite, true), ...filters))
            .groupBy(metricNameColumn)
            .orderBy(asc(countAlias))
            .limit(limit);
        const [topValuesResult, topRatedResult, topFavoritedResult] =
            await Promise.all([topValuesQuery.execute(), topRatedQuery.execute(), topFavoritedQuery.execute()]);
        return {
            topValues: topValuesResult.map((row) => ({
                name: row.name,
                value: row.value || 0,
            })),
            topRated: topRatedResult.map((row) => ({
                name: row.name,
                value: Math.round((row.value || 0) * 100) / 100,
            })),
            topFavorited: topFavoritedResult.map((row) => ({
                name: row.name,
                value: row.value || 0,
            })),
        };
    }
}
export const isValidFilter = (value: any) => {
    return Array.isArray(value) && value.length > 0 && value[0] !== ALL_VALUE;
}
export const createListFilterDef = ({ argName, entityTable, filterColumn, mediaTable }: ListFilterDefinition) => {
    return {
        isActive: (args: MediaListArgs) => isValidFilter(args[argName]),
        getCondition: (args: MediaListArgs) => {
            const subQuery = getDbClient()
                .select({ mediaId: entityTable.mediaId })
                .from(entityTable)
                .where(inArray(filterColumn, args[argName] as string[]));
            return inArray(mediaTable.id, subQuery);
        },
    } as FilterDefinition;
}




================================================================
End of Codebase
================================================================

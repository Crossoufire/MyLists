    // getPublisherAchievementCte(_achievement: Achievement, userId?: number) {
    //     const { mediaTable, listTable } = this.config;
    //
    //     const subQ = getDbClient()
    //         .select({
    //             userId: listTable.userId,
    //             count: count(listTable.mediaId).as("count"),
    //         })
    //         .from(listTable)
    //         .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id))
    //         .where(
    //             and(
    //                 eq(listTable.status, Status.COMPLETED),
    //                 userId ? eq(listTable.userId, userId) : undefined,
    //             ),
    //         )
    //         .groupBy(listTable.userId, mediaTable.publishers)
    //         .as("sub");
    //
    //     return getDbClient()
    //         .select({
    //             userId: subQ.userId,
    //             value: max(subQ.count).as("value"),
    //         })
    //         .from(subQ)
    //         .groupBy(subQ.userId)
    //         .as("calculation");
    // }
    //
    // getChapterAchievementCte(_achievement: Achievement, userId?: number) {
    //     const { listTable } = this.config;
    //
    //     const baseCTE = getDbClient()
    //         .select({
    //             userId: listTable.userId,
    //             value: sum(listTable.total).as("value"),
    //         })
    //         .from(listTable);
    //
    //     return this.applyUserFilterAndGrouping(baseCTE, [], userId);
    // }
    //
    // getAuthorAchievementCte(_achievement: Achievement, userId?: number) {
    //     const { authorsTable, listTable, mediaTable } = this.config;
    //
    //     const subQ = getDbClient()
    //         .select({
    //             userId: listTable.userId,
    //             count: count(listTable.mediaId).as("count"),
    //         })
    //         .from(listTable)
    //         .innerJoin(authorsTable, eq(listTable.mediaId, authorsTable.mediaId))
    //         .where(and(
    //             eq(listTable.status, Status.COMPLETED),
    //             userId ? eq(listTable.userId, userId) : undefined,
    //         ))
    //         .groupBy(listTable.userId, authorsTable.name)
    //         .as("sub");
    //
    //     return getDbClient()
    //         .select({
    //             userId: subQ.userId,
    //             value: max(subQ.count).as("value"),
    //         })
    //         .from(subQ)
    //         .groupBy(subQ.userId)
    //         .as("calculation");
    // }
    //
    // getLanguageAchievementCte(_achievement: Achievement, userId?: number) {
    //     const { listTable, mediaTable } = this.config;
    //
    //     const baseCTE = getDbClient()
    //         .select({
    //             userId: listTable.userId,
    //             value: count(listTable.mediaId).as("value"),
    //         })
    //         .from(listTable)
    //         .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id));
    //
    //     const conditions = [eq(listTable.status, Status.COMPLETED)];
    //
    //     // This query requires a HAVING clause, which is applied after grouping
    //     const userFilter = userId ? [eq(listTable.userId, userId)] : [];
    //     return baseCTE
    //         .where(and(...conditions, ...userFilter))
    //         .groupBy(listTable.userId)
    //         .having(gte(countDistinct(mediaTable.language), 2))
    //         .as("calculation");
    // }
    //
    // getGameModeAchievementCte(achievement: Achievement, userId?: number) {
    //     const { listTable, mediaTable } = this.config;
    //
    //     const baseCTE = getDbClient()
    //         .select({
    //             userId: listTable.userId,
    //             value: count(listTable.id).as("value"),
    //         })
    //         .from(listTable)
    //         .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id));
    //
    //     const conditions = [
    //         ilike(mediaTable.gameModes, `%${achievement.value}%`),
    //         notInArray(listTable.status, [Status.PLAN_TO_PLAY, Status.DROPPED]),
    //     ];
    //
    //     return this.applyUserFilterAndGrouping(baseCTE, conditions, userId);
    // }
    //
    // getCompanyAchievementCte(achievement: Achievement, userId?: number) {
    //     const { listTable, companiesTable } = this.config;
    //     const isDeveloper = achievement.value === "developer";
    //
    //     const subQ = getDbClient()
    //         .select({
    //             userId: listTable.userId,
    //             count: count(listTable.mediaId).as("count"),
    //         })
    //         .from(listTable)
    //         .innerJoin(companiesTable, eq(listTable.mediaId, companiesTable.mediaId))
    //         .where(and(
    //             notInArray(listTable.status, [Status.PLAN_TO_PLAY, Status.DROPPED]),
    //             isDeveloper ? eq(companiesTable.isDeveloper, true) : eq(companiesTable.isPublisher, true),
    //             userId ? eq(listTable.userId, userId) : undefined,
    //         ))
    //         .groupBy(listTable.userId, companiesTable.name)
    //         .as("sub");
    //
    //     return getDbClient()
    //         .select({
    //             userId: subQ.userId,
    //             value: max(subQ.count).as("value"),
    //         })
    //         .from(subQ)
    //         .groupBy(subQ.userId)
    //         .as("calculation");
    // }
    //
    // getPerspectiveAchievementCte(achievement: Achievement, userId?: number) {
    //     const { listTable, mediaTable } = this.config;
    //
    //     const baseCTE = getDbClient()
    //         .select({
    //             userId: listTable.userId,
    //             value: count(listTable.mediaId).as("value"),
    //         })
    //         .from(listTable)
    //         .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id));
    //
    //     const conditions = [
    //         notInArray(listTable.status, [Status.PLAN_TO_PLAY, Status.DROPPED]),
    //         eq(mediaTable.playerPerspective, achievement.value),
    //     ];
    //
    //     return this.applyUserFilterAndGrouping(baseCTE, conditions, userId);
    // }
    //
    // getPlatformAchievementCte(_achievement: Achievement, userId?: number) {
    //     const { listTable } = this.config;
    //
    //     const baseCTE = getDbClient()
    //         .select({
    //             userId: listTable.userId,
    //             value: countDistinct(listTable.platform).as("value"),
    //         })
    //         .from(listTable);
    //
    //     const conditions = [notInArray(listTable.status, [Status.PLAN_TO_PLAY, Status.DROPPED]),];
    //
    //     return this.applyUserFilterAndGrouping(baseCTE, conditions, userId);
    // }
    //
    // getSpecificPlatformAchievementCte(achievement: Achievement, userId?: number,) {
    //     const { listTable } = this.config;
    //
    //     const baseCTE = getDbClient()
    //         .select({
    //             userId: listTable.userId,
    //             value: count(listTable.mediaId).as("value"),
    //         })
    //         .from(listTable);
    //
    //     const conditions = [
    //         notInArray(listTable.status, [Status.PLAN_TO_PLAY, Status.DROPPED]),
    //         eq(listTable.platform, achievement.value),
    //     ];
    //
    //     return this.applyUserFilterAndGrouping(baseCTE, conditions, userId);
    // }
    //
    // getPlaytimeAchievementCte(_achievement: Achievement, userId?: number) {
    //     const { listTable } = this.config;
    //
    //     const baseCTE = getDbClient()
    //         .select({
    //             userId: listTable.userId,
    //             value: sql<number>`sum(${listTable.playtime}) / 60`.as("value"),
    //         })
    //         .from(listTable);
    //
    //     return this.applyUserFilterAndGrouping(baseCTE, [], userId);
    // }
    //
    // getNetworkAchievementCte(_achievement: Achievement, userId?: number) {
    //     const { listTable, networkTable, mediaTable } = this.config;
    //
    //     const baseCTE = getDbClient()
    //         .select({
    //             userId: listTable.userId,
    //             value: countDistinct(networkTable.name).as("value"),
    //         })
    //         .from(listTable)
    //         .innerJoin(mediaTable, eq(listTable.mediaId, mediaTable.id))
    //         .innerJoin(networkTable, eq(mediaTable.id, networkTable.mediaId));
    //
    //     const conditions = [not(eq(listTable.status, Status.PLAN_TO_WATCH))];
    //
    //     return this.applyUserFilterAndGrouping(baseCTE, conditions, userId);
    // }